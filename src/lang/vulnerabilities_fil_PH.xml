<?xml version="1.0" encoding="utf-8" ?>
<vulnerabilities xmlns="http://tempuri.org/XMLSchemaOptions.xsd">

<vuln_items>wasc_1</vuln_items>
<vuln_item_wasc_1>
	<alert>Hindi sapat na nagpapatunay</alert>
	<desc>Hindi sapat na nagpapatunay ay nangyayari kapag ang isang web site ay nagpapahintulot sa attacker na ma-access ang sensitibo o functionality nang hindi na kinakailangang mapatunayan ng wasto. Web-based na administrasyon na mga gamit ay isang magandang halimbawa ng mga web sites na pagbibigay ng access sa sensitibong pag-andar. Depende sa partikular na online na pagkukunan, ang mga web applications ay hindi dapat direktang naa-access nang hindi nangangailangan ng gumagamit upang maayos na mapatunayan ang kanilang pagkakakilanlan.

Upang makakuha sa paligid ng pag-set up sa authentication, ilang resources ay hindi protektado ng "pagtatago" ang tiyak na lokasyon at hindi nag-uugnay sa lokasyon sa pangunahing web site o iba pang mga pampublikong lugar. Gayunpaman, ang paraang ito ay hindi higit kaya sa mga "Security Through Obscurity". Ito ay mahalaga na maunawaan na kahit na isang resource na ito ay hindi kilala sa attacker, ito pa rin ay nanatiling magagamit ng direkta sa isang partikular na URL. Ang partikular na URL ay mangyaring natuklasan sa pamamagitan ng isang Brute Force na paraan para sa mga common file at mga lokasyon ng direktoryo (/admin para sa halimbawa), ang mga maling mensahe, referrer logs, o dokumento tulad ng mga help files. Ang mga pagkukunan, kung sila ay nilalaman o pagpapagana-hinihimok, dapat sapat protektado.</desc>
	<solution>Yugto: Arkitektura at Disenyo
Gamitin ang pagpapatunay na framework o library na tulad ng OWASP ESAPI Authentication feature.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Authentication</reference>
	<reference>http://cwe.mitre.org/data/definitions/287.html</reference>
	<reference>http://cwe.mitre.org/data/definitions/284.html</reference>
</vuln_item_wasc_1>

<vuln_items>wasc_2</vuln_items>
<vuln_item_wasc_2>
	<alert>Hindi sapat na pagpapatunay</alert>
	<desc>Hindi sapat na pagpagtunay na mga resulta kapag ang isang application ay hindi nagsasagawa ng sapat na pahintulot upang matiyak ang pagsasagawa ng gumagamit o pag-access ng datos sa paraang naayos sa patakaran sa seguridad. Mga pagpapahintulot na mga procedure ay dapat ipapatupad kung anong user, serbisyo o aplikasyon ay pinahintulutang gawin. Nang ang gumamit ay mapagtibay sa isang web site, ito ay hindi nangangahulugan na ang mga gumagamit ay dapat magkaroon ng full access sa lahat ng nilalaman at mga functionality.

Hindi sapat ang Function Authorization

Maraming mga applications ang pinagkaloob ng iba't ibang mga aplikasyon functionality ng iba't ibang mga gumagamit. Isang news site na ito ay nagpapahintulot sa mga gumagamit na makita ang mga kuwento ng balita, pero hindi na ilathala sa kanila. Isang accounting na sistema ay nagkakaroon ng iba't ibang mga pahintulot para sa isang Accounts Payable clerk at isang Accounts Receivable clerk. Kulang ang kakayahan ng awtorisasyon ay nangyayari kapag ang isang aplikasyon ay hindi pumipigil sa mga taga-gamit na ma-dagdag ang pag-andar ng aplikasyon na lumalabag sa patakaran sa katiwasayan.

Isang malinaw na halimbawa ay ang 2005 na pag-hack ng proseso ng aplikasyon ng Harvard Business School. An authorization failure allowed users to view their own data when they should not have been allowed to access that part of the web site.
 
Hindi sapat na Data Authorization

Maraming mga applications ang inilantad na batayan ng pagkakailan sa isang URL. Halimbawa, kapag ina-access ang isang medikal na talaan sa isang sistema ng isa ay magkaroon ng isang URL tulad ng:

http://example.com/RecordView?id=12345

Kung ang aplikasyon ay hindi sunusuri na yung mga naka-authenticated na user ID ay mayroong karapatan sa pagbasa, at pagkatapos ay maidispley itong mga datos para sa gumagamit ay dapat hindi makita.

Hindi sapat na Data Authorization ay mas karaniwan kaya sa hindi sapat na Function Authorization dahil ang mga programmer karaniwang nagkaroon ng kumpletong kaalaman sa functionality ng aplikasyon, ngunit hindi laging may isang kumpletong mapping ng lahat ng data na ma-access ang mga aplikasyon. Mga programmer ay madalas magkaroon ng mahigpit na kontrol sa mga function authorization mechanisms, ngunit umaasa sa iba pang mga sistema tulad ng mga database upang masagawa ang pahintulot ng datos.</desc>
	<solution>Yugto: Arkitektura at Disenyo; Operasyon ay mabuting pinamahala ang settings, management, at paghawak ng mga pribilehiyo. Malinaw na pagpapangasiwa ng mga trust zones sa software.

Yugto: Arkitektura at Disenyo
Pagsiguro na ang nararapat na compartmentalization ay naitayo into sa sistema ng disenyo at na ang compartmentalization ay nagbibigay pahintulot para sa pagpapalakas ng pahintulot sa separation functionality. Mga arkitekto at mga designers ay dapat umasa sa prinsipyo ng pinakamaliit na pribilehiyong magdesisyon kapag ang mga ito ay nararapat na gamitin at drop sa sistema ng mga pribilehiyo.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Authorization</reference>
	<reference>http://cwe.mitre.org/data/definitions/284.html</reference>
	<reference>http://cwe.mitre.org/data/definitions/285.html</reference>
</vuln_item_wasc_2>

<vuln_items>wasc_3</vuln_items>
<vuln_item_wasc_3>
	<alert>Nag-uumapaw ang integer</alert>
	<desc>Ang integer Overflow ay kondisyon na nangyayari kapag ang resulta ng isang pang-aritmetic operasyon, tulad ng pagpaparami o karagdagan, ay lampas na sa pinakamalaking sukat ng integer type na ginagamit para maitago ito. Kapag ang integer overflow ay nagaganap, lilitaw ang mga naisalin na halaga "wrapped around" ang pinakamataas ng halaga ay nagsimula muli sa pinakamababang halaga, katulad ng isang orasan na kumakatawan sa 13:00 sa pamamagitan ng pagturo sa 1:00.

Halimbawa, isang 8-bit nilagdaan na integer sa pinaka-karaniwang na arkitektura ng computer ay may isang pinakamataas na halaga ng 127 at isang pinakamababa na halaga na -128. Kung ang programmer ay nag-stores ng halaga na 127 sa naturang isang variable at nagdadagdag ng 1 na ito, ang resulta ay dapat 128. Gayunman, ang halaga ay lumampas ang pinakamataas para sa ganitong uri ng integer, kaya ang naisalin na halaga ay "wrap around" at maging ang -128.</desc>
	<solution>Yugto: Mga requirements
Pagsiguro na ang lahat ng mga protocols ay istriktong itinutukoy, Gayon man ang lahat ng mga out-of-bounds behavior ay kiniala ang simple, at kinakailangan ang istriktong conformance sa protocol.

Yugto: Mga Requirements
Paggamit ng wika na hindi nag pahintulot sa gamitong mga kahinaan o nagbibigay ng constructs na gumagawa ng kahinaan na madaling itong maiwasan.
Kung posibleng, makapili ng wika o compiler na gumagawa ng automatic bounds checking.

Yugto: Arkitekture at Disenyo
Gamitin ang vetted library o framework na hindi nag papahintulot ng kaninaan para mangyari o nagbibigay constructs na gumagawa ng kahinaan na madaling maiwasan.
Gamitin ng mga aklatan o mga balangkas na pinapadaling mahawakan ang mga numero nang walang hindi akalaing mga kahihinatnan.
Mga Halimbawa ang mga ligtas na pagbuo sa pagkapit ng pagbubuo tulad ng SafeInt (C++) o IntegerLib (C or C++.

Salita: Pagsasagawa
Magsagawa ng pagpapatunay ng pag-input sa anumang numerong input sa pamamagitan ng pagtutukoy sa nasa loob ng inaasahan na saklaw. Pilitin na matugunan ng input ang parehong pinakamababa at pinakamataas na kinakailangan para sa inaasahang saklaw.
Gamitin ang hindi na pirmahang pambuo kung saan posible. Ito ay ginagawang mas madali ang pagsasagawa ng mga pag-susuri ng katinuan para sa overflow ng pagbubuo. Ito ay kung dapat mong gumamit ng mga na pirmahang pagbubuo, siguraduhin na ang iyong hanay ng pagsusuri ay may kasamang mga pinakamababa na halaga pati na rin ang pinakamataas na halaga.

Panimula: pagsasagawa
Intindihin ang pinagbabatayang representasyon ng lengguwahe ng iyong palatuntunan at kung paano ito maiuugnay sa pagkalkula ng numerong (CWE-681). Mag-bigay alintana sa pagkakaiba ng byte, katumpakan, naka-pirma / hindi-pirma mga pagkakakilanlan, pag-putol, pag-salin at paghahagis sa pagitan ng mga anyo, mga "hindi-isang-bilang" na kalkulasyon, at kung paano ang iyong lengguwahe ay humahawak ng mga numero na masyadong malaki o masyadong maliit para sa pinagbabatayang paglalarawan nito.
Kailangan mag-ingat sa account para sa 32-bit, 64-bit, at iba pang maaaring pagkakaiba na pweding makaapekto sa Nauukol sa bilang na representasyon.

Panimula: pagsasagawa
Ang pag-susuri ng mga tagatipon ng babala at alisin ang maaring mga problema na pangkaligtasan sa katiwasayan, tulad ng naka-pirma / hindi naka-pirma ay hindi magkatulad. Maski na ang kahinaan ay bihira na nagagamit, ang isang kabiguan ay maaaring mapunta sa pangako ng buong sistema.</solution>
	<reference>http://projects.webappsec.org/Integer-Overflows</reference>
	<reference>http://cwe.mitre.org/data/definitions/190.html</reference>
</vuln_item_wasc_3>

<vuln_items>wasc_4</vuln_items>
<vuln_item_wasc_4>
	<alert>Kulang ang pag-lipat ng patong na proteksyon</alert>
	<desc>Kulang ang pag-lipat ng patong na proteksyon
Kulang ang pag-lipat ng patong na proteksyon pinahihintulutan ang komunikasyon na mahayag sa hindi pinagkakatiwalaan na mga third party, na nagbibigay ng isang attack vector upang mangako ang isang web aplikasyon at / o kumuha ng sensitibong kaalaman. Ang karamihan ng website ay gumagamit ng Secure Sockets Layer / Transport Layer Security (SSL / TLS) upang maghanda ng encryption sa transport layer. Gaano man, maliban kung wala ang website ay naka-configure na gagamitin SSL/TLS at naka-configure upang gamitin SSL/TLS maayos, pweding mahina ang website sa pagharang ng trapiko at pagbabago.
 
Sa kawalan ng transport patong encryption nang transport ay hindi encrypted patong, ng lahat ng komunikasyon sa pagitan ng mga website na kliyente ay nagsugo na linisin ang teksto na ang mga dahon pagbuksan pati, injection at redirection (kilala rin bilang man-in-the-middle/MITM attack). Ang isang pag-salakay ay maaaring pumipigil sa komunikasyon, na nagbibigay sa kanila ng daan sa anumang sensitibong datos na ipadala gaya ng mga ginagamit na pagngalan at password. Ang isang pag-salakay ay pwede ring aktibong mag-iniksyon/mag-tanggal ng nilalaman mula sa komunikasyon, na nagpapahintulot sa pag-atake ng pag-salakay at pag-omit ng kaalaman, mag-impok ng malisyosong pag-script, o maging sanhi ng kliyente na ma-kadaan ang remote sa hindi pinagkakatiwalaang nilalaman. Ang isang pagsalakay ay pwedi ring dumirekta ang komunikasyon sa isang paraan na ang website at kliyente ay hindi na makapagsabi sa isa't isa, ngunit sa halip ay hindi makilala ang pakikipag-usap sa pagsalakay sa konteksto ng iba pang pinagkakatiwalaang pangkat.

Ang Cipher Support ay Mahina
Sa pangkasaysayan, ang mataas na ranggo ng cryptography ay pinag-takda mula sa pag-luwas sa labas ng Estados Unidos. Dahil dito ang, websites ay kailangan naka configure upang masupportahan ang mahinang cryptographic na pagpipilian para s mga kliyente na pinag-takda lamang sa paggamit ng mga mahinang ciphers. Ang mahina na ciphers ay hindi-ligtas laban sa pag-atake dahil sa kamag-anak na kadalian ng pagwasak sa kanila; mas mababa sa dalawang linggo sa isang pangkaraniwan na kompyuter sa bahay at ilang segundo gamit ang dedikadong hardware.
Ngayon, ang lahat ng mga modernong browser at mga website ay ginagamit ng mas malakas na encryption, subalit ang ilang mga website ay naka-configure pa rin upang masuportahan ang mga laos na mahinang ciphers. Dahil dito, ang isang pagsalakay ay pweding mapilit ang client na i-baba sa isang mahinang cipher kapag kumukonekta sa website, na nagpapahintulot sa pagsalakay na sirain ang mahinang pag-encrypt. Dahil sa kadahilanang ito, dapat i-configure ang server upang tanggapin lamang ang mga malalakas na ciphers at hindi magbibigay ng paglilingkod sa anumang kliyente na humiling ng paggamit ng mahinang cipher. Sa karagdagan, ang ilang mga website ay may maling pag-kaayos upang pumili ng isang mahina na cipher kahit na ang kliyente ay sinusuportahan sa isang mas malakas na isa. Nag-aalok ang OWASP ng gabay sa pagsusuri para sa mga problema ng SSL / TLS, kabilang ang mahinang suporta sa cipher at misconfiguration, at may iba pang mga mapagkukunan at kasangkapan pati na rin.</desc>
	<solution>Malinis na tukuyin kung aling mga datos o mga mapagkukunan ay sapat na mahalaga na dapat silang protteksyunan sa pag-encrypt. Hiling√≠n na ang anumang paghahatid o pag-imbak ng datos / mapagkukunan na ito ay dapat gumamit ng gumagana na vetted na mga algorithm ng pag-encrypt.

Yugto: Arkitektura at Plano
Gamit ang pagmomolde ng pagbabanta o iba pang mga pamamaraan, ipalagay na ang iyong dattos ay maaaring makompromiso sa pamamagitan ng isang hiwalay na kahinaan o kahinaan, at matukoy kung saan ang encryption ay pweding pinaka-epektibo. Siguraduhin na ang datos na pinaniniwalaan mong dapat na pribado ay hindi sinasadyang ma-expose gamit ang mga kahinaan tulad ng hindi secure na mga permiso (CWE-732).

Yugto: Arkitektura at desenyo
siguraduhin na ang encrytion ay naintegrated sa system ng design kasama narin pero hindi kailangang limitahan.
ang encryption ay kailangang maitago o mailagay sa pribadong datos ng mga gumagamit o may nag mamay ari ng system
Ang encryption ay kailangang protektahan ang system mismo  sa mga hindi awtorisadong pagsisiwalat o pakikialam.
alamin ang mga kailangang at separadong konteksto ng encryption. Ito ay makakamit sa pamamagitan ng pampublikong susi o pamamaraan ng crytography, o ibang teknik kung san ang encryting party (i.e.,ang software)ay hindi kailangang magkaroon ng access para sa pribadong key o pamamaraan.
      Dalawang daan(i.e.,ang encryption ay pwedeng mag awtomatik sa pag galaw o pag perform sa ngalan ng may nagmamay ari, pero ang key ay kailangang maging available o kailangan magamit nang sa ganoo ang plaintext ay awtomatikong ma rerecover o maaaring marecover ng nag mamay ari). Ito ay nangangailangan ng mapag iimbakan ng mga pribadong key sa format na maaaring marecover pa ng mismong nag mamay ari (o kaya ng operating system o sa nag ooperate ng system) sa paraan na hindi marerecover ng iba.

Yugto: Arkitektura at Desenyo
Huwag mag develop o gumawa ng sariling crytographic algorithms. Maaring may mga naka exposed o nakalantad para umatake para sa mga nakakaalam ng cryptograps. Ang mga teknik ng reverse engineering ay pang bihasa. Kung ang algorithm ay makompormiso ng mga sumasalakay at malaman kung papaano ito gumagana, ang ibig sabihin nito na algorithm ay mahina.

Yugto: Arkitektura at Desenyo 
Piliin ang ang magaling o magandang vetted algorithm na kasalukuyang itunuturing na malakas ng mga eksperto sa larangan ng arkitektura, at piliin ang magaling o magandang vetted na pinatutupad.
Halimbawa, ang Sistema ng Gobyerno ng Estados Unidos ay kailangan ng FIPS 140-2 na katunayan o katibayan.
Katulad ng lahat ng mga mapaparaan ng kriptograpiko, ang source code ay kailangan magagamit sa pag aanalize.
Laging tiyakin na hindi ka gumagamit ng lipas o wala ng bisang kriptograpi. Ang ibang matanda o lumang algorithms, minsang napag isipan kailanganan ng bilyong taon para sa suma ng oras, ngayon ay kayang buwagin o sirain ng isang araw o ilang oras lamang. Kasama nito ang MD4, MD5, SHA1 DES, at ang ibang algorithms kung saan ang mga ito ay pinagpipitagan bilang malakas.

Yugto: Arkitektura at Desenyo
pag samasamahinang iyongmga sistema ng sagoon ay magkaroon ka ng seguridad. sa lugar na kung saan ay nagtitiwala kang hindi ito magagalaw o makukuha ng iba. Huwag payagan ang mga sensitibong datos na mag punta sa labas ng pinagkaktiwalaang lugar o lalagyanan at kaialngang lagi ay maging maingat lalo na sa pag interface sa mga kasama sa labas ng ligtas na lalagyan o lugar.

Yugto: Implementasyon; Arkitektura at Desenyo
Kapag ikaw gumagamit ng pang industriyang na aprobahan ng mga teknik, ikaw ay kailangan na gamitin ng tama. Huwag gupitin o hatiin ang sulok sa pamamagitan ng paglaktaw ng mapagkukunan ng matinding hakbang.(cwe-325). Narito ang mga hakbang na palaging ginagamit o karanawang ginagamit para maiwasan ang mga sumasalakay.

Yugto: Implementasyon
Gumamit ng pangalan na gianmitan ng mga pang konbesyon at malakas na uri upang makagawa ng mas madaling spot kapag sensitibo ang datos na ginagamit. Kapag lumilikha ng mga istruktura, mga bagay, o iba pang mga kumplikadong mga entity, ihiwalay ang sensitibo at hindi-sensitibong datos hangang sa maaari.
Ginagawa nitong mas madali na makita ang mga lugar sa code kung saan ang datos ay ginamit na unencrypted.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Transport-Layer-Protection</reference>
	<reference>http://cwe.mitre.org/data/definitions/311.html</reference>
</vuln_item_wasc_4>

<vuln_items>wasc_5</vuln_items>
<vuln_item_wasc_5>
	<alert>Pagbuo ng remote na file</alert>
	<desc>Pag buo ng file. Kapag ang aplikante ng webay kumuha ng user input (URL, halaga ng parametro, atb.) at naipasa nila sa file kasama ang mga utos, ang aplikante ng web ay maaring ma trick kasama ang remote na files na may kasamang malisyosong code.

Halos lahat ng aplikante ng web ay framework ay kasama ng suportang file. Ang pag sasama ng file ay isa sa pinkaginagamit para sa pag papack ng karaniwang code para sa separadong files na kadalasang ay nagiging sanggunnihan ng pangkalahatang aplikante ng modyul. Kapag ang web na aplikasyon ay nagmungkahi na isama ang file, ang code para dito ay maaring ibigay sa pamamaraang pagtawag o pagbibigay ng partikular na pamamaraan. Kapag ang napili mong modyul ay para mag lagay ng batayan ng mga elemento galing sa HTTP na hiling. ang web na aplikasyon ay maaring mahina sa RFI.
Ang umaatake ay may kakayahang gumamit ng RFI para sa. Kapag ang file ay hindi na execute o naisagawa gamit ang ilang wrapper, ang code sa kasamang file ay maisasagawa sa konteksto ng gumagamit ng servver. Ito ay maaring mag bigay daan para sa kumpletong sistema ng kompormiso.
    *Ang pagtakbo o pag gamit ng malisyosong code sa kliyente. ang mga umaatake ay may malisyosong code na pwedeng imanipulate ang nilalaman ng mga kapalit na pag bigay sa kliyente. Ang umaatake ay kayang kumuha ng mga malisyosong code na pabalik na pwedeng magpatakbo ng mga kliyente (halimbawa, javascript para makuha ang session cookies ng kliyente.

PHP ay partikular na mahina para sa RFI na umaatake sa mga di kasamang pag gamit ng "file includes" sa PHP na programa at dahil sa default server ang pag gamit ng configuration ay tumataas ng pagkakamaramdamin ng RFI attack.</desc>
	<solution>Yugto: Arkitektura at Plano
Kung nakatakda o kilala ang hanay ng mga katanggap-tanggap na bagay, tulad ng mga pangalan ng file o URL, gumawa ng isang pagmamap mula sa isang hanay ng mga nakapirming halaga ng input (tulad ng mga numerong ID) sa aktwal na mga pangalan ng filename o URL, at tanggihan ang lahat ng iba pang mga input.
Para sa halimbawa, ID 1 pweding e map sa "inbox.txt" at ID 2 pweding e map sa "profile.txt". Ang mga tampok kapareho ng ESAPI AccessReferenceMap ay naglalaan ng kakayahan na ito.

Mga yugto: Arkitektura at plano; Operasyon
Paganahin ang iyong code sa isang "bilangguan" o kapareho na sandbox ng kapaligiran na nagpapatupad ng mahirap na mga hangganan sa pagitan ng pag-proseso ng operating system. Ito ay maaring epektibong restrict kung saan ang files ay pwedeng magamit sa partikular na directory o kung saan ang utos ay maaring magamit o maisagawa ng iyong software.
Ang OS-level ay mga ehemplo na kasama ang Unix chroot jail. AppArmor, at SELinux. Sa pangakalahatan, ang pag mamanage ng code ay pwedeng magbigay ng ilang proteksyon. Halimbawa, java.io FilePermission sa mga Java SecurityManager na mag aallow sayo ng pagtukoy sa mga restrictions o sa mga mahigpit na file na operasyon.
Ito ay maaring di magawan ng solusyon, at ito ay limitasyon sa pag impact ng mga sitemang nag ooperate; at ang lahat ng iyong aplikasyon ay maaring maging paksa para sa kompormiso.
Mag-ingat at iwasan ang CWE-243 at ang ibang mahihina na may kaugnayan sa bilangguan.
Para sa PHP ang interpreter o tagasalin ng wika ay nag ooffer ng restrictions sa mga bukas na basedir o ligtas nga mode kung saan pwedeng gawing mas mahirap para sa umaatake na makaiwas sa labas ng aplikasyon. Isaalang alang din ang Suhosin, a pinagtibay ng PHP extension, kung saan ito ay kasama sa ibat ibang opsyonal na maaring mag disable o hindi mapagawa ang marami pang mas mapanganib na PHP na maga tampok.

Yugto: pagpapatupad
Ipagpalagay na ang lahat ng input ay malisyoso. Gamitin ang "accept known good"mahusay na pagtanngap at pagkilala o ang pag validate ng input na stratehiya,i.e., gamitin ang puting listahan o whitelist para sa pagtanggap ng ng mga input na striktong sumusunod sa pagtukoy. Tanggihan ang mga input na hindi strikto sa pag conform sa pagtutukoy o sa pag transform nito sa ibang bagay na ginagawa nito. Huwag mag rely sa eksklusibon na pagtingin sa malisyosong o di maayos na input(i.e.,huwag mag rely sa itim na listahan o sa blacklist). Gayon pa man, ang itim na listahan o ang blacklist ay maaaring magamit para sa pagdetect ng potensyal na atake o sa pagtukoy ng mga inputs ay hindi maayos na maaring tanggihan agad.
Kapag ginagamit ang input na validation, iconsider na ang lahat ng potensyal na may kaugnayan sa mga properties, kasama na rito ang haba, tipo ng input, ang buong kakayahan ng pagtanggap ng halaga, kawalan o iba pang inputs, syntax, pagkakapareho sa mga parehong larangan at pagsang-ayon sa mga panuntunan sa negosyo. Bilang isang halimbawa ng lohika sa patakaran sa negosyo, ang "bangka" ay pweding tama syntactically dahil naglalaman lamang ito ng mga alphanumeric na pag-uugali, ngunit hindi ito tama kung umaasa ka ng mga kulay na kapareho ng "red" o "blue."
Para sa mga filename, gamitin ang mga mahigpit na whitelist na lumilimita sa hilera ng character na gagamitin. Kung magagawa, pahintulutan lamang ang isang solong "." karakter sa filename upang maiwasan ang mga kahinaan kagaya ng CWE-23, 
at ihiwalay ang mga separator ng direktoryo kagaya ng "/" upang maiwasan CWE-36. Gumamit ng whitelist na nagpapahintulot sa lawig ng file, na maaring makakatulong upang maiwasan ang CWE-434.

Mga yugto: Arkitektura at plano; Operasyon
Magtabi ng aklatan, isama, at mga utility file sa labas ng web document root, kung pepwedi. O kaya, i-store sila sa isang nakahiwalay na direktoryo at gamitin ang mga kakayahan ng access kontrol ng web server para mapigilan ang mga aatake mula sa direktang pag-hiling sa kanila. Isang karaniwang pagsasanay ay ang pagtukoy sa isang fixed na constant sa bawat calling program, pagkatapos ay ang pag-check sa pagkakaroon ng constant sa library/include file; kung ang constant aay hindi umiiral, kung gayon ang file ay direktang iniling, at ito ay maaaring i-exit kaagad.
Ito ay makabuluhang magpapababa ng tsansa ng isang aatake na magawang lagpasan ang anumang mga mekanismong proteksyon na nasa base program ngunit hindi nasa include files. Mababawasan din nito ang iyong attack surface.

Yugto: Arkitektura at Plano; Pagpapatupad
Maunawaan ang lahat ng mga potensyal na lugar kung saan pweding ipasok ng mga hindi pinagkakatiwalaang input ang iyong software: mga parameter o argumento, cookies, sa anumang nabasa mula sa network, mga baryante ng kapaligiran, saliwang pag-tingin sa taas ng DNS, mga resulta ng tanong, sa ulo ng kahilingan, mga bahagi ng URL, e-mail, mga file, database, at anumang mga panlabas na sistema na nagbibigay ng datos sa pagpapairal. Tandaan na ang mga ganong input ay maaaring hindi direktang makuha sa pamamagitan ng mga API call.
Many file inclusion problems occur because the programmer assumed that certain inputs could not be modified, especially for cookies and URL components.</solution>
	<reference>http://projects.webappsec.org/Remote-File-Inclusion</reference>
	<reference>http://cwe.mitre.org/data/definitions/98.html</reference>
</vuln_item_wasc_5>

<vuln_items>ang wasc_6</vuln_items>
<vuln_item_wasc_6>
	<alert>String ng Format</alert>
	<desc>Ang pagbago ng pag-atake ng String ng ayos ang daloy ng isang pag-papairal sa pamamagitan ng paggamit ng mga tampok sa pag-ayos ng format ng library upang ma-kadaan ang iba pang espasyo ng memorya. Ang mga kahinaan ay nangyayari kapag ang datos na naibigay ng taga-gamit ay direktang ginagamit bilang pag-format ng input ng string para sa ilang C/C++ functions (e.g. fprintf, printf, sprintf, setproctitle, syslog, ...).

Kung ang isang sasalakay ay makapasa sa isang format na string na binubuo ng mga character ng printf na pinag-usapan (e.g. "%f", "%p", "%n", etc.) bilang isang parameter na halaga sa web aplikasyon, pwedi silang:
    * Ipatupad ang arbitrary code ng server
    * Basahin ng mga halaga mula sa stack
    * Ang sanhi ng mga pagkakamali ng segmentation / pag-kasira ng software

Ang pag-atake ng string ay may kaugnayan sa iba pang mga pag-atake sa banta ng pag-uuri: Buffer pag-apaw sa pag-apaw ng Integer. Ang lahat ng tatlo ay batay sa kanilang kakayahan na mamahala ang memorya o interpretasyon nito sa isang paraan na nag-aambag sa layunin ng magsasalakay.</desc>
	<solution>Ang yugto: pangangailangan
Pumili ng isang lengguwahe na hindi napapailalim sa lamat na ito.

Ang yugto: Pagpapatupad
Siguraduhin na ang lahat ng mga tungkuli ng format ng string ay pinapasa sa isang estatika na string na hindi pweding kontrolin ng gumagamit at ang tamang bilang ng mga argumento ay palaging ipinapadala sa tungkulin na rin. Kung posible, gumamit ng mga function na hindi sumusuporta sa %n operator sa mga format string.
Build: Heed the warnings of compilers and linkers, since they may alert you to improper usage.
</solution>
	<reference>http://projects.webappsec.org/Format-String</reference>
	<reference>http://cwe.mitre.org/data/definitions/134.html</reference>
</vuln_item_wasc_6>

<vuln_items>ang wasc_7</vuln_items>
<vuln_item_wasc_7>
	<alert>Ang umaapaw na buffer</alert>
	<desc>Ang Buffer Overflow ay isang lamat na nangyayari kapag mas maraming datos ang nakasulat sa isang bloke ng memorya, o buffer, kaysa sa buffer ay inilaan upang hawakan. Ang pagargabyado sa overflow ng buffer ay nagbibigay-daan sa isang magsasalakay na baguhin ang mga bahagi ng patlang na kinaroroonan ng target na pag-proseso. Ang kakayahan na ito ay pweding magamit para sa maraming layunin, kabilang ang mga sumusunod:
    * ang pag-kontrol sa pagpapatupad ng proseso
    * Sirain ang pag-proseso
    * Baguhin ang panloob na mga baryante

Ang layunin ng magsasalakay ay halos palaging makontrol ang pagpapatupad ng target na pag-proseso. Ito ay maisasagawa sa pamamagitan ng pagtukoy sa isang function pointer sa memorya na maaaring mabago, direkta o hindi direkta, gamit ang overflow. Kapag ang naturang pointer ay nagagamit ng programa upang maidirekta ang pagsasagawa ng programa sa pamamagitan ng pagtalon o pagtawag sa pagtuturo, gainagamit ang lokasyon ng pagtuturo na ibinigay ng pagsalakay, sa gayon ay pinahihintulutan ang magsasalakay na kontrolin ang proseso.

Sa maraming mga kaso, ang tungkulin ng pointer ay binabago upang i-sanguni ang isang lokasyon kung saan ang magsasalakay ay nakalagay na nagsama ng mga tagubilin sa makina na natukoy. Ang mga instruksyon na ito ay karaniwang tinatawag bilang shellcode, batay sa katotohanan na ang mga aatake ay kalimitang humihiling na i-spawn ang command-line na environment, o shell, sa konteksto ng tumatakbong proseso.

Buffer overflows are most often associated with software written in the C and C++ programming languages due to their widespread use and ability to perform direct memory manipulation with common programming constructs. It should be emphasized, however, that buffer overflows can exist in any programming environment where direct memory manipulation is allowed, whether through flaws in the compiler, runtime libraries, or features of the language itself.
</desc>
	<solution>Yugto: Mga Requirements
Paggamit ng wika na hindi nag pahintulot sa gamitong mga kahinaan o nagbibigay ng constructs na gumagawa ng kahinaan na madaling itong maiwasan.
Halimbawa, maraming mga lengguwahe na nagsasagawa ng kanilang sariling pamamahala sa memorya, tulad ng Java at Perl, ay hindi napapasailalim sa overflows ng buffer. Ibang mga lengguwahe, tulad ng Ada at c#, karaniwang nagbibigay ng proteksyon sa overflow, ngunit ang proteksyon ay maaaring hindi paganahin ng programmer.
Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.

Yugto: Arkitekture at Disenyo
Gamitin ang vetted library o framework na hindi nag papahintulot ng kaninaan para mangyari o nagbibigay constructs na gumagawa ng kahinaan na madaling maiwasan.
Examples include the Safe C String Library (SafeStr) by Messier and Viega, and the Strsafe.h library from Microsoft. These libraries provide safer versions of overflow-prone string-handling functions. This is not a complete solution, since many buffer overflows are not related to strings.

Ang yugto: Ang pag-tatag at pag-samasama
Patakbuhin o tipunin ang iyong software gamit ang mga tampok o lawig na awtomatikong nagbibigay ng mekanismo ng proteksyon na nagpapagaan o nag-aalis ng overflow ng buffer.
Ang halimbawa, ang ilang mga taga-tipun at mga lawig ay nagbibigay ng awtomatikong mekanismo ng pag-tuklas ng overflow ng buffer na itinatag sa naimbak na code. Ang kalakip sa mga halimbawa ang flag ng Microsoft Visual Studio /GS, Fedora/Red Hat FORATIFY SOURCE GCC flag, StackGuard, at ProPolice.

Ang Yugto: Pagpapatupad
gunitain ang pagsunod sa mga sumusunod na alituntunin kapag naglalaan at namamahala ng memorya ng isang aplikasyon:
     doublehin ang pag-suri kung ang buffer mo ay kasing dami ng iyong tinukoy.
      Kapag gumagamit ng mga function na tumatanggap ng isang bilang ng bytes para kopyahin, tulad ng strncpy(), magkaroon ng kamalayan na kung ang sukat ng destination buffer ay katumbas ng sukat ng source buffer, ito ay maaaring hindi mag NULL-terminate ng string.
      Check buffer boundaries if calling this function in a loop and make sure you are not in danger of writing past the allocated space.
      If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.

Ang Yugto: Operasyon
Ang pag-gamit ng isang tampok tulad ng Address Space Layout Randomization (ASLR).

Ang Yugto: Operasyon

Ang pag-gamit ng CPU at operating system na nag-aalok ng Data Execution Protection (NX) o kahambing nito.

Ang Yugto: Pagpapatupad

Ang pag-papalit ng mga limitasyon ng mga tungkulin ng kopya na may mga analog na tungkulin na suportado ng mga argumento ng haba, kagaya ng strcpy na may strncpy. Gawin ito kung, ito ay hindi pwedi.
</solution>
	<reference>http://projects.webappsec.org/Buffer-Overflow</reference>
	<reference>http://cwe.mitre.org/data/definitions/119.html</reference>
</vuln_item_wasc_7>

<vuln_items>ang wasc_8</vuln_items>
<vuln_item_wasc_8>
	<alert>Ang cross-site na scripting</alert>
	<desc>Ang Cross-site na scripting (XSS) ay isang atake na technique na bumabalot ng echoing ng attacker-supplied na code sa loob ng isang user browser na instance. Ang isang browser instance ay pwedeng isang standard web browser na client, o isang browser object embedded sa isang software produkto tulad ng browser sa loob ng WinAmp, isang RSS na reader, o isang email client. The code itself is usually written in HTML/JavaScript, but may also extend to VBScript, ActiveX, Java, Flash, or any other browser-supported technology.
When an attacker gets a user's browser to execute his/her code, the code will run within the security context (or zone) of the hosting web site. With this level of privilege, the code has the ability to read, modify and transmit any sensitive data accessible by the browser. A Cross-site Scripted user could have his/her account hijacked (cookie theft), their browser redirected to another location, or possibly shown fraudulent content delivered by the web site they are visiting. Cross-site Scripting attacks essentially compromise the trust relationship between a user and the web site. Applications utilizing browser object instances which load content from the file system may execute code under the local machine zone allowing for system compromise.

There are three types of Cross-site Scripting attacks: non-persistent, persistent and DOM-based.
Non-persistent attacks and DOM-based attacks require a user to either visit a specially crafted link laced with malicious code, or visit a malicious web page containing a web form, which when posted to the vulnerable site, will mount the attack. Ang paggamit ng isang malisyosong form ay kalimitang nagaganap kapag ang tinatanggap lamang ng vulnerable resource ang HTTP POST na mga kahilingan. In such a case, the form can be submitted automatically, without the victim's knowledge (e.g. by using JavaScript). Upon clicking on the malicious link or submitting the malicious form, the XSS payload will get echoed back and will get interpreted by the user's browser and execute. Another technique to send almost arbitrary requests (GET and POST) is by using an embedded client, such as Adobe Flash.
Persistent attacks occur when the malicious code is submitted to a web site where it's stored for a period of time. Examples of an attacker's favorite targets often include message board posts, web mail messages, and web chat software. The unsuspecting user is not required to interact with any additional site/link (e.g. an attacker site or a malicious link sent via email), just simply view the web page containing the code.</desc>
	<solution>Yugto: Arkitekture at Disenyo
Gamitin ang vetted library o framework na hindi nag papahintulot ng kaninaan para mangyari o nagbibigay constructs na gumagawa ng kahinaan na madaling maiwasan.
Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.

Yugto: Implementasyon; Arkitektura at Desenyo
Intindihin ang konteksto kung saan ang iyong datos ay pwedeng gamitin at ang pag encode ay expected. Ito ay espesyal at importante kapag nag tatransmit o nag papasa ng datos sa pagitan ng mag kaibang components o mga sangkap. o kapag nag gegenerate ng mga output na maaaring may laman na maraming mga encoding sa parehong oras, tulad ng mga pahina sa web o sa maraming parte ng sulat at mensahe. Pag aralan ang lahat na inaasahang komyunikasyon protokol at datos ng representation na makilala o matukoy ang kinikailangang pag eencode at mga estratehiya.
Kahit na sa anong datos ay magiging output sa ibang pahina ng web, lalo na ang ibang datos na matatanggap sa labas ng mga input, gamitin ang tamang pag eencode sa lahat ng non-alphanuemeric na karakter.
Kumunsulta sa XSS para sa pag iwas ng madayang pilas ng papel o Prevention Cheat Sheet para sa mas maraming detalye sa mga uri ng pag eencoode at sa pagtakas na kinakailangan.

Yugto: Arkitektura at Disenyo 
Para sa ibang seguradid na pag suri na ang pag perform sa kliyente, siguraduhin na ang pag susuri ay dalawa para naman sa server, upang maiwasan ang CWE-602. Ang mga umaatake ay maaring bypass sa side ng kliyente suriin ang modipikasyon ng halaga bago pa matapos ang pagsusuri ay magawa, o sa pagbabago ng kliyente sa pagtanggal ng kabuoang pag susuri sa kliyente. Pagkatapos, ang modipikasyon ng halaga ay maaaring ipasa sa server.

Kung may magagamit o may mapapakinabangan, gamitin ang structued na mekanismo na awtomatikong mag eenforce ng separado sa pagitan ng datos at code. Ang Mekanismong ito ay maaring mag provide o maghanda ng may kaugnayan sa quoting, pag eencode at sa awtomatikong balidasyon, sa halip na umasa ang mga nag develope ang gumawa ng kapasidad o kakayahan sa lahat ng pagkakataon kapag ang output ay nagenerate.

Yugto: Implementasyon
Para sa lahat ng pahina ng web na nag gegnerate, gamitin ang specify na karakter sa pag eencode tulad ng ISO-8859-1 or UTF-8. Kapag ang pag eencode ay hindi specified o hindi kilala, ang web na browser ay pipili ng ibang encoding gamit ang pag hahanap ng ibang encoding na nagamit na ng pahina ng web. Ito ay maaaring magdulot sa web browser ng trato sa tiyak na sequences bilang espesyal na pag bubukas ng kliyente sa banayad na XSS na mga atake. Tignan ang CWE-116 para sa mas maraming mitigasyon na may kaugnayan sa pag eencode/at pagtakas.

Para matulungan ang mitigasyon sa mga umaatake sa XSS laban sa gumagamit ng session cookie, ihanda ang session cookie sa HttpOnly. Ang pag suporta HttpOnly ng browser ay tampok (tulad ng mas maraming kamakailang bersyon ng internet explorer ang Firefox), ang attribute na ito ay maaaring pigilan ng mga gumagamit ng session na cookie galing sa maaring puntahan na malisyosong eskripto ng kliyente na gumagamit ng dokomento ng cookie. Ito ay hindi kumpletong solusyon, since ang HttpOnly ay hindi sinuportahan ng lahat ng browser. Ang mas mahalaga, XMLHTTPRequest at ang ibang mas malakas na teknolohiya ng browsers na nagbibigay ng pag basa at pag tukoy sa HTTp headers, kasama na rito ang sert ng cookie header kung saan ang HttpOnly flag ay na set.

Ipagpalagay ang lahat ng input ay malisyoso. Gamitin ang "accept known good"mahusay na pagtanngap at pagkilala o ang pag validate ng input na stratehiya,i.e., gamitin ang puting listahan o whitelist para sa pagtanggap ng ng mga input na striktong sumusunod sa pagtukoy. Tanggihan ang mga input na hindi strikto sa pag conform sa pagtutukoy o sa pag transform nito sa ibang bagay na ginagawa nito. Huwag mag rely sa eksklusibon na pagtingin sa malisyosong o di maayos na input(i.e.,huwag mag rely sa itim na listahan o sa blacklist). Gayon pa man, ang itim na listahan o ang blacklist ay maaaring magamit para sa pagdetect ng potensyal na atake o sa pagtukoy ng mga inputs ay hindi maayos na maaring tanggihan agad.

Kapag ginagamit ang input na validation, iconsider na ang lahat ng potensyal na may kaugnayan sa mga properties, kasama na rito ang haba, tipo ng input, ang buong kakayahan ng pagtanggap ng halaga, kawalan o iba pang inputs, syntax, pagkakapareho sa mga parehong larangan at pagsang-ayon sa mga panuntunan sa negosyo. Bilang ehemplo ng negosyo sa panuntunan ng lohika, " bangka" ay may systacticaally na balido sapagkat ito lamang ang naglalaman ng alphanumeric na karakter, pero ito ay hindi balido kung ang iyong inaasahang kulay at "pula at asul."

Pakariguraduhin na ang pag perform ng input ay balido sa sa well mga interface sa mga aplikasyon. Ito ay makakatulong sa aplikasyon kahit na ang mga component o mga nilalaman ay nagamit na o nailagay kung saan man.
	</solution>
	<reference>http://projects.webappsec.org/Cross-Site-Scripting</reference>
	<reference>http://cwe.mitre.org/data/definitions/79.html</reference>
</vuln_item_wasc_8>

<vuln_items>wasc_9</vuln_items>
<vuln_item_wasc_9>
	<alert>Kahilingan para sa Cross Site</alert>
	<desc>Ang kahilingan para sa cross site ay isang atake na kasangkot sa pagpwersa ng biktima na magpadala ng HTTP na hiling sa mga target na destinasyon na walang kaalaman o intensyon na mag perform ng ibang aksyon ng mga biktima. Ang cause na pinagbabatayan ng aplikasyon ng funcionality na ginamit sa pag predikta ng URL/uri ng aksyon na umuulit na paraan. Ang kalikasan ng pag atake ay ang CSRF na kapakinabangan ng tiwala ng web site para sa gumagamit. Sa kabilang banda, ang cross site scripting (XSS) ay may kapakinabangan na ang gumagamit ay para sa web site. Katulad ng XSS, CSRF ang mga atake ay hindi necessarily ng cross-site pero hindi maaari. Ang Cross site ay kahilingan ng 
forgery ay isa sa kilalang CSRF, XSRF, isang pindot ng pag atake. ang session riding, ang nalitong representante, at ang see surf.

CSRF na pag atake ay epektibo sa mga bilang na sitwasyon, kasama na rito ang 
*Ang biktima ay aktibong session sa mga target na site.
    *Ang biktima ay awtentikado via HTTP auth sa mga target na site.
    *Ang biktima ay na sa parehong lokal na network sa mga target na site.

CSRF ay pangunahing nagagamit para mag perform ng aksyon laban sa target na site gamit ang pribelihiyo ng biktima, pero ang kamakailang teknik ay natuklasana na isiwalat o ipaalam sa iba ang impormasyon sa pamamagitan ng pag kakaroon ng mga sagot. Ang panganib ng impormasyon na pag siwalat ay kapansin pansing pagtaas kapag ang target na site ay mahina sa XSS, dahil ang XSS ay ginagamit bilang platform ng CSRF, pinapayagang umatake at mag operate hanggang sa kanilang kakayahan sa parehong pinanggalingan ng palisiya.</desc>
	<solution>Yugto: Arkitekture at Disenyo
Gamitin ang vetted library o framework na hindi nag papahintulot ng kaninaan para mangyari o nagbibigay constructs na gumagawa ng kahinaan na madaling maiwasan.
Ang halibawa, gumamit ng anti-CSRF na pakete katulad ng OWASP CSRFGuard.

Yugto: Implementsyon
Pakasiguraduhin na ang aplikasyon ay di ginagamit o libre sa mga cross site scripting issues, dahil ang pinaka depensa ng CSRF ay pwedeng mabypassed gamit ang umaatake na kontrolado ng script.

Yugto: Arkitektura at Desenyo 
Bumuo ng kakaibang nonce para sa lahat ng porma, lugar at sa nonce sa mga porma, at maiverify o maalam ang nonce na resibo ng mga porma. Be sure that the nonce is not predictable (CWE-330).
Note that this can be bypassed using XSS.

Identify especially dangerous operations. When the user performs a dangerous operation, send a separate confirmation request to ensure that the user intended to perform that operation.
Note that this can be bypassed using XSS.

Use the ESAPI Session Management control.
This control includes a component for CSRF.

Do not use the GET method for any request that triggers a state change.

Ang Yugto: Pagpapatupad
Suriin ang header ng HTTP Referer upang makita kung ang kahilingan ay nagmula sa isang inaasahang pahina. This could break legitimate functionality, because users or proxies may have disabled sending the Referer for privacy reasons.</solution>
	<reference>http://projects.webappsec.org/Cross-Site-Request-Forgery</reference>
	<reference>http://cwe.mitre.org/data/definitions/352.html</reference>
</vuln_item_wasc_9>

<vuln_items>wasc_10</vuln_items>
<vuln_item_wasc_10>
	<alert>Denial of Service</alert>
	<desc>Denial of Service (DoS) is an attack technique with the intent of preventing a web site from serving normal user activity. DoS attacks, which are easily normally applied to the network layer, are also possible at the application layer. These malicious attacks can succeed by starving a system of critical resources, vulnerability exploit, or abuse of functionality.

Many times DoS attacks will attempt to consume all of a web site's available system resources such as: CPU, memory, disk space etc. When any one of these critical resources reach full utilization, the web site will normally be inaccessible.

As today's web application environments include a web server, database server and an authentication server, DoS at the application layer may target each of these independent components. Unlike DoS at the network layer, where a large number of connection attempts are required, DoS at the application layer is a much simpler task to perform.</desc>
	<solution>Phase: Architecture and Design

Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.

Mitigation of resource exhaustion attacks requires that the target system either:
      recognizes the attack and denies that user further access for a given amount of time, or
      uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed. 

The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, he may be able to prevent the user from accessing the server in question.

The second solution is simply difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply makes the attack require more resources on the part of the attacker.

Ensure that protocols have specific limits of scale placed on them.

Phase: Implementation
Ensure that all failures in resource allocation place the system into a safe posture.</solution>
	<reference>http://projects.webappsec.org/Denial-of-Service</reference>
	<reference>http://cwe.mitre.org/data/definitions/400.html</reference>
</vuln_item_wasc_10>

<vuln_items>wasc_11a</vuln_items>
<vuln_item_wasc_11a>
	<alert>Brute Forcing Log-in Credentials</alert>
	<desc>A brute force attack is a method to determine an unknown value by using an automated process to try a large number of possible values. The attack takes advantage of the fact that the entropy of the values is smaller than perceived. For example, while an 8 character alphanumeric password can have 2.8 trillion possible values, many people will select their passwords from a much smaller subset consisting of common words and terms.

The most common type of a brute force attack in web applications is an attack against log-in credentials. Since users need to remember passwords, they often select easy to memorize words or phrases as passwords, making a brute force attack using a dictionary useful. Such an attack attempting to log-in to a system using a large list of words and phrases as potential passwords is often called a "word list attack" or a "dictionary attack". Attempted passwords may also include variations of words common to passwords such as those generated by replacing "o" with "0" and "i" with "1" as well as personal information including family member names, birth dates and phone numbers.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11a>

<vuln_items>wasc_11b</vuln_items>
<vuln_item_wasc_11b>
	<alert>Brute Forcing Session Identifiers</alert>
	<desc>A brute force attack is a method to determine an unknown value by using an automated process to try a large number of possible values. The attack takes advantage of the fact that the entropy of the values is smaller than perceived. For example, while an 8 character alphanumeric password can have 2.8 trillion possible values, many people will select their passwords from a much smaller subset consisting of common words and terms.

Since HTTP is a stateless protocol, in order to maintain state web applications need to ensure that a session identifier is sent by the browser with each request. The session identifier is most commonly stored in an HTTP cookie or URL. Using a brute force attack, an attacker can guess the session identifier of another user. This can lead to the attacker impersonating the user, retrieving personal information and performing actions on behalf of the user.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11b>

<vuln_items>wasc_11c</vuln_items>
<vuln_item_wasc_11c>
	<alert>Brute Forcing Directories and Files</alert>
	<desc>A brute force attack is a method to determine an unknown value by using an automated process to try a large number of possible values. The attack takes advantage of the fact that the entropy of the values is smaller than perceived. For example, while an 8 character alphanumeric password can have 2.8 trillion possible values, many people will select their passwords from a much smaller subset consisting of common words and terms.

When files reside in directories that are served by the web server but are not linked anywhere, accessing those files requires knowing their file name. In some cases those files have been left by mistake: for example a backup file automatically created when editing a file or leftovers from an older version of the web application. In other cases files are intentionally left unlinked as a "security by obscurity" mechanism allowing only people who know the file names to access them.

A brute force attack tries to locate the unlinked file by trying to access a large number of files. The list of attempted file names might be taken from a list of known potential files or based on variants of the visible files on the web site. More information on brute forcing directories and files can be found in the associated vulnerability, predictable resource location.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11c>

<vuln_items>wasc_11d</vuln_items>
<vuln_item_wasc_11d>
	<alert>Brute Forcing Credit Card Information</alert>
	<desc>A brute force attack is a method to determine an unknown value by using an automated process to try a large number of possible values. The attack takes advantage of the fact that the entropy of the values is smaller than perceived. For example, while an 8 character alphanumeric password can have 2.8 trillion possible values, many people will select their passwords from a much smaller subset consisting of common words and terms.

Shopping online with stolen credit cards usually requires information in addition to the credit card number, most often the CVV/SCS and/or expiration date. A fraudster may hold a stolen credit card number without the additional information. For example the CVV/CSC is not imprinted on the card or stored on the magnetic stripe so it cannot be collected by mechanical or magnetic credit card swiping devices.

In order to fill in the missing information the hacker can guess the missing information using a brute force technique, trying all possible values.
    * Guessing CVV/CSC requires only 1000 or 10000 attempts as the number is only 3 or 4 digits, depending on the card type.
    * Guessing an expiration date requires only several dozen attempts.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11d>

<vuln_items>wasc_12</vuln_items>
<vuln_item_wasc_12>
	<alert>Content Spoofing</alert>
	<desc>Ang nilalaman ng Spoofing ay isang atake sa kakayahan na nagbibigay-daan sa isang magsasalakay upang mag-iniksyon ng isang hindi magandang kargamento na mamaya misrepresented bilang lehitimong nilalaman ng isang web aplikasyon.
 
Ang teksto na nilalaman lamang ng Spoofing
Ang isang pangkaraniwang kakayahan sa mga pahina ng dynamic na pagtatag ay nagsasangkot ng pagpasa sa katawan o mga bahagi nito sa pahina sa pamamagitan ng tanong na halaga ng string. This approach is common on error pages, or sites providing story or news entries. The content specified in this parameter is later reflected into the page to provide the content for the page.
 
Markup Reflected Content Spoofing
Some web pages are served using dynamically built HTML content sources. For example, the source location of a frame <frame src="http://foo.example/file.html"/>) could be specified by a URL parameter value. (http://foo.example/page?frame_src=http://foo.example/file.html). An attacker may be able to replace the "frame_src" parameter value with "frame_src=http://attacker.example/spoof.html". Unlike redirectors, when the resulting web page is served the browser location bar visibly remains under the user expected domain (foo.example), but the foreign data (attacker.example) is shrouded by legitimate content.

Specially crafted links can be sent to a user via e-mail, instant messages, left on bulletin board postings, or forced upon users by a Cross-site Scripting attack. If an attacker gets a user to visit a web page designated by their malicious URL, the user will believe he is viewing authentic content from one location when he is not. Users will implicitly trust the spoofed content since the browser location bar displays http://foo.example, when in fact the underlying HTML frame is referencing http://attacker.example.

This attack exploits the trust relationship established between the user and the web site. The technique has been used to create fake web pages including login forms, defacements, false press releases, etc.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Content-Spoofing</reference>
	<reference>TBA</reference>
</vuln_item_wasc_12>

<vuln_items>wasc_13</vuln_items>
<vuln_item_wasc_13>
	<alert>Information Leakage</alert>
	<desc>Information Leakage is an application weakness where an application reveals sensitive data, such as technical details of the web application, environment, or user-specific data. Sensitive data may be used by an attacker to exploit the target web application, its hosting network, or its users. Therefore, leakage of sensitive data should be limited or prevented whenever possible. Information Leakage, in its most common form, is the result of one or more of the following conditions: A failure to scrub out HTML/Script comments containing sensitive information, improper application or server configurations, or differences in page responses for valid versus invalid data.

Failure to scrub HTML/Script comments prior to a push to the production environment can result in the leak of sensitive, contextual, information such as server directory structure, SQL query structure, and internal network information. Often a developer will leave comments within the HTML and/or script code to help facilitate the debugging or integration process during the pre-production phase. Although there is no harm in allowing developers to include inline comments within the content they develop, these comments should all be removed prior to the content's public release.

Software version numbers and verbose error messages (such as ASP.NET version numbers) are examples of improper server configurations. This information is useful to an attacker by providing detailed insight as to the framework, languages, or pre-built functions being utilized by a web application. Most default server configurations provide software version numbers and verbose error messages for debugging and troubleshooting purposes. Configuration changes can be made to disable these features, preventing the display of this information.

Pages that provide different responses based on the validity of the data can also lead to Information Leakage; specifically when data deemed confidential is being revealed as a result of the web application's design. Examples of sensitive data includes (but is not limited to): account numbers, user identifiers (Drivers license number, Passport number, Social Security Numbers, etc.) and user-specific information (passwords, sessions, addresses). Information Leakage in this context deals with exposure of key user data deemed confidential, or secret, that should not be exposed in plain view, even to the user. Credit card numbers and other heavily regulated information are prime examples of user data that needs to be further protected from exposure or leakage even with proper encryption and access controls already in place.</desc>
	<solution>Compartmentalize your system to have "safe" areas where trust boundaries can be unambiguously drawn. Huwag payagan ang mga sensitibong datos na mag punta sa labas ng pinagkaktiwalaang lugar o lalagyanan at kaialngang lagi ay maging maingat lalo na sa pag interface sa mga kasama sa labas ng ligtas na lalagyan o lugar.</solution>
	<reference>http://projects.webappsec.org/Information-Leakage</reference>
	<reference>http://cwe.mitre.org/data/definitions/200.html</reference>
</vuln_item_wasc_13>

<vuln_items>wasc_14</vuln_items>
<vuln_item_wasc_14>
	<alert>Server Misconfiguration</alert>
	<desc>Server Misconfiguration attacks exploit configuration weaknesses found in web servers and application servers. Many servers come with unnecessary default and sample files, including applications, configuration files, scripts, and web pages. They may also have unnecessary services enabled, such as content management and remote administration functionality. Debugging functions may be enabled or administrative functions may be accessible to anonymous users. These features may provide a means for a hacker to bypass authentication methods and gain access to sensitive information, perhaps with elevated privileges.

Servers may include well-known default accounts and passwords. Failure to fully lock down or harden the server may leave improperly set file and directory permissions. Misconfigured SSL certificates and encryption settings, the use of default certificates, and improper authentication implementation with external systems may compromise the confidentiality of information.

Verbose and informative error messages may result in data leakage, and the information revealed could be used to formulate the next level of attack. Incorrect configurations in the server software may permit directory indexing and path traversal attacks.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Server-Misconfiguration</reference>
	<reference></reference>
</vuln_item_wasc_14>

<vuln_items>wasc_15</vuln_items>
<vuln_item_wasc_15>
	<alert>Application Misconfiguration</alert>
	<desc>Application Misconfiguration attacks exploit configuration weaknesses found in web applications. Many applications come with unnecessary and unsafe features, such as debug and QA features, enabled by default. These features may provide a means for a hacker to bypass authentication methods and gain access to sensitive information, perhaps with elevated privileges.

Likewise, default installations may include well-known usernames and passwords, hard-coded backdoor accounts, special access mechanisms, and incorrect permissions set for files accessible through web servers. Default samples may be accessible in production environments. Application-based configuration files that are not properly locked down may reveal clear text connection strings to the database, and default settings in configuration files may not have been set with security in mind. All of these misconfigurations may lead to unauthorized access to sensitive information.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Application-Misconfiguration</reference>
	<reference></reference>
</vuln_item_wasc_15>

<vuln_items>wasc_16</vuln_items>
<vuln_item_wasc_16>
	<alert>Directory Indexing</alert>
	<desc>Automatic directory listing/indexing is a web server function that lists all of the files within a requested directory if the normal base file (index.html/home.html/default.htm/default.asp/default.aspx/index.php) is not present. When a user requests the main page of a web site, they normally type in a URL such as: http://www.example.com/directory1/ - using the domain name and excluding a specific file. The web server processes this request and searches the document root directory for the default file name and sends this page to the client. If this page is not present, the web server will dynamically issue a directory listing and send the output to the client. Essentially, this is equivalent to issuing an "ls" (Unix) or "dir" (Windows) command within this directory and showing the results in HTML form. From an attack and countermeasure perspective, it is important to realize that unintended directory listings may be possible due to software vulnerabilities (discussed in the example section below) combined with a specific web request.</desc>
	<solution>Recommendations include restricting access to important directories or files by adopting a need to know requirement for both the document and server root, and turning off features such as Automatic Directory Listings that could expose private files and provide information that could be utilized by an attacker when formulating or conducting an attack.</solution>
	<reference>http://projects.webappsec.org/Directory-Indexing</reference>
	<reference>http://cwe.mitre.org/data/definitions/548.html</reference>
</vuln_item_wasc_16>

<vuln_items>wasc_17</vuln_items>
<vuln_item_wasc_17>
	<alert>Improper Filesystem Permissions</alert>
	<desc>Improper filesystem permissions are a threat to the confidentiality, integrity and availability of a web application. The problem arises when incorrect filesystem permissions are set on files, folders, and symbolic links. When improper permissions are set, an attacker may be able to access restricted files or directories and modify or delete their contents. For example, if an anonymous user account has write permission to a file, then an attacker may be able to modify the contents of the file influencing the web application in undesirable ways. An attacker may also exploit improper symlinks to escalate their privileges and/or access unauthorized files; for example, a symlink that points to a directory outside of the web root.</desc>
	<solution>Very carefully manage the setting, management and handling of permissions. Explicitly manage trust zones in the software.</solution>
	<reference>http://projects.webappsec.org/Improper-Filesystem-Permissions</reference>
	<reference>http://cwe.mitre.org/data/definitions/280.html</reference>
</vuln_item_wasc_17>

<vuln_items>wasc_18</vuln_items>
<vuln_item_wasc_18>
	<alert>Credential and Session Prediction</alert>
	<desc>Credential/Session Prediction is a method of hijacking or impersonating a web site user. Deducing or guessing the unique value that identifies a particular session or user accomplishes the attack. Also known as Session Hijacking, the consequences could allow attackers the ability to issue web site requests with the compromised user's privileges.

Many web sites are designed to authenticate and track a user when communication is first established. To do this, users must prove their identity to the web site, typically by supplying a username/password (credentials) combination. Rather than passing these confidential credentials back and forth with each transaction, web sites will generate a unique "session ID" to identify the user session as authenticated. Subsequent communication between the user and the web site is tagged with the session ID as "proof" of the authenticated session. If an attacker is able predict or guess the session ID of another user, fraudulent activity is possible.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Credential-and-Session-Prediction</reference>
	<reference></reference>
</vuln_item_wasc_18>

<vuln_items>wasc_19</vuln_items>
<vuln_item_wasc_19>
	<alert>SQL Injection</alert>
	<desc>Ang SQL Injection ay isang kakayahan ng pag-atake na ginagamit upang abusohin ang mga aplikasyon na bumuo ng mga pahayag ng SQL mula sa input na ibinigay ng taga-gamit. Kung magiging matagumpay, ang pag-atake ay pwedi mong baguhin ang lohika ng SQL pahayag na isinasagawa kontra sa database.

Ang Structured Query Language (SQL) ay isang espesyal na programang pang lengguwahe para sa pagpapadala ng mga tanong sa mga database. Ang SQL programang pang lengguwahe ay parehong isang ANSI at isang normal na ISO, bagamat maraming mga produkto ng database na suportado ang SQL gawin ito sa mga pagmamay-ari ng lawig sa karaniwang lengguwahe. Ang mga aplikasyon ay kadalasang gumagamit ng datos na ibinigay ng taga-gamit upang gumawa ng mga salaysay ng SQL. Kung ang isang aplikasyon ay nabigo upang maayos na bumuo ng mga SQL na salaysay posible para sa isang pagsalakay upang baguhin ang istraktura ng pahayag at ipatupad ang hindi na plano at potensyal na hahamon sa utos. Kapag ang mga utos na ito ay ipinapatupad, ginagawa nila ito sa ibaba ng konteksto ng taga-gamit na tinukoy ng aplikasyon na ipinapatupad ang salaysay. This capability allows attackers to gain control of all database resources accessible by that user, up to and including the ability to execute commands on the hosting system.</desc>
	<solution>Yugto: Arkitekture at Disenyo
Gamitin ang vetted library o framework na hindi nag papahintulot ng kaninaan para mangyari o nagbibigay constructs na gumagawa ng kahinaan na madaling maiwasan.
Ang halimbawa, kosedirahin ang paggamit ng mga hanay ng pagtitiyaga tulad ng Hibernate o Enterprise Java Beans, na pweding magbigay ng makabuluhang seguridad kontra sa SQL injection kung gagamitin nang maayos.

Kung may magagamit o may mapapakinabangan, gamitin ang structued na mekanismo na awtomatikong mag eenforce ng separado sa pagitan ng datos at code. Ang Mekanismong ito ay maaring mag provide o maghanda ng may kaugnayan sa quoting, pag eencode at sa awtomatikong balidasyon, sa halip na umasa ang mga nag develope ang gumawa ng kapasidad o kakayahan sa lahat ng pagkakataon kapag ang output ay nagenerate.

Process SQL queries using prepared statements, parameterized queries, or stored procedures. These features should accept parameters or variables and support strong typing. Do not dynamically construct and execute query strings within these features using "exec" or similar functionality, since you may re-introduce the possibility of SQL injection.

Run your code using the lowest privileges that are required to accomplish the necessary tasks. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.

Specifically, follow the principle of least privilege when creating user accounts to a SQL database. The database users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others' data. Use the strictest permissions possible on all database objects, such as execute-only for stored procedures.

Ang Yugto: Pagpapatupad
Kung kinakailangan mong gumamit ng mga string ng tanong o direksiyon na dinamiko binuo sa kabila ng panganib, maayos na mag-tukoy
 ng mga argumento at makawala sa anumang mga espesyal na character sa loob ng mga argumento. Ang pinaka-konserbatibong paraan ay upang makawala o mag-sala ng lahat ng mga character na hindi nakapasa sa isang lubos na mahigpit na whitelist (tulad ng lahat ng bagay na hindi alphanumeric o puting patlang). Kung kinakailangan ng mo ng ilang mga espesyal na character, tulad ng puting patlang, balutin ang bawat argumento sa mga panipi pagkatapos ng pagtakas/hakbang sa pagsala. Mag-ingat sa argumento ng injection (CWE-88).

Sa halip na pagbuo ng iyong sariling pagsasagawa, ang mga tampok na ito ay pweding makakuha sa database o lengguwahe ng programa. Ang halimbawa, ang Oracle DBMS ASSERT na pakete ay pweding suriin o isagawa ang mga parameter ay may ilang mga pag-aari na nagpapahina sa kanila sa SQL injection. Para sa MySQL, ang mysql tunay na pag-takas na string() API 
Ang tungkulin ay magagamit sa parehong C at PHP.

Ipagpalagay ang lahat ng input ay malisyoso. Gamitin ang "accept known good"mahusay na pagtanngap at pagkilala o ang pag validate ng input na stratehiya,i.e., gamitin ang puting listahan o whitelist para sa pagtanggap ng ng mga input na striktong sumusunod sa pagtukoy. Tanggihan ang mga input na hindi strikto sa pag conform sa pagtutukoy o sa pag transform nito sa ibang bagay na ginagawa nito. Huwag mag rely sa eksklusibon na pagtingin sa malisyosong o di maayos na input(i.e.,huwag mag rely sa itim na listahan o sa blacklist). Gayon pa man, ang itim na listahan o ang blacklist ay maaaring magamit para sa pagdetect ng potensyal na atake o sa pagtukoy ng mga inputs ay hindi maayos na maaring tanggihan agad.

Kapag ginagamit ang input na validation, iconsider na ang lahat ng potensyal na may kaugnayan sa mga properties, kasama na rito ang haba, tipo ng input, ang buong kakayahan ng pagtanggap ng halaga, kawalan o iba pang inputs, syntax, pagkakapareho sa mga parehong larangan at pagsang-ayon sa mga panuntunan sa negosyo. Bilang isang halimbawa ng lohika sa tuntunin sa negosyo, ang "bangka" ay maaaring tama syntactically dahil naglalaman lamang ito ng mga alphanumeric na character, subalit hindi ito wasto kung umaasa ka sa mga kolor tulad ng "red" o "blue.". Ito ay hindi direktang nalilimitahan ang sakop ng isang pag-atake, subalit ang pamamaraan na ito ay mas mahalaga kaysa sa tamang pag-pasok ng output at pag-alis.

Note that proper output encoding, escaping, and quoting is the most effective solution for preventing SQL injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent SQL injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, the name "O'Reilly" would likely pass the validation step, since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the "'" apostrophe character, which would need to be escaped or otherwise handled. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.

When feasible, it may be safest to disallow meta-characters entirely, instead of escaping them. This will provide some defense in depth. After the data is entered into the database, later processes may neglect to escape meta-characters before use, and you may not have control over those processes.</solution>
	<reference>http://projects.webappsec.org/SQL-Injection</reference>
	<reference></reference>
</vuln_item_wasc_19>

<vuln_items>wasc_20</vuln_items>
<vuln_item_wasc_20>
	<alert>Improper Input Handling</alert>
	<desc>Ang hindi wastong paghawak sa pag-input ay isa sa mga pinakakaraniwang kahinaan na natunton sa buong mga aplikasyon ngayon. Ang hindi magandang pagdederekta sa pag-input ay isang pangunahing dahilan sa likuran ng mga kritikal na kahinaan na umiiral sa mga sistema at aplikasyon.
	
Sa pangkalahatan, ang pangmatagalang pagpasok ng input ay ginagamit upang isalarawan ang mga tungkulin kagaya ng pagpapatunay, sanitization, pag-sasala, pag-papasok at/o pag-labas ng datos ng pag-input. Ang mga aplikasyon ay nakakakuha ng input mula sa iba't ibang mga mapagkukuhaan kasama ang mga taga-gamit ng tao, mga ahente ng software (mga browser), at mga network/peripheral na aparato upang makapagtala ng ilang pangalan. Sa kaso ng mga aplikasyon sa web, pweding mailipat ang input sa iba't ibang mga ayos (name value pairs, JSON, SOAP, etc...) at mkakuha sa pamamagitan ng mga string ng tanong sa URL, POST data, HTTP headers, Cookies, etc... Non-web application input can be obtained via application variables, environment variables, the registry, configuration files, etc... Regardless of the data format or source/location of the input, all input should be considered untrusted and potentially malicious. Applications which process untrusted input may become vulnerable to attacks such as Buffer Overflows, SQL Injection, OS Commanding, Denial of Service just to name a few.

One of the key aspects of input handling is validating that the input satisfies a certain criteria. For proper validation, it is important to identify the form and type of data that is acceptable and expected by the application. Defining an expected format and usage of each instance of untrusted input is required to accurately define restrictions. 

Validation can include checks for type safety and correct syntax. String input can be checked for length (min and max number of characters) and character set validation while numeric input types like integers and decimals can be validated against acceptable upper and lower bound of values. When combining input from multiple sources, validation should be performed during concatenation and not just against the individual data elements. This practice helps avoid situations where input validation may succeed when performed on individual data items but fails when done on a combined set from all the sources.</desc>
	<solution>Phase: Architecture and Design

Use an input validation framework such as Struts or the OWASP ESAPI Validation API.

Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, databases, and any external systems that provide data to the application. Tandaan na ang mga ganong input ay maaaring hindi direktang makuha sa pamamagitan ng mga API call.

For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side. Ang mga umaatake ay maaring bypass sa side ng kliyente suriin ang modipikasyon ng halaga bago pa matapos ang pagsusuri ay magawa, o sa pagbabago ng kliyente sa pagtanggal ng kabuoang pag susuri sa kliyente. Pagkatapos, ang modipikasyon ng halaga ay maaaring ipasa sa server.

Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.

Do not rely exclusively on blacklist validation to detect malicious input or to encode output. There are too many ways to encode the same character, so you're likely to miss some variants.

When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.

Ipagpalagay ang lahat ng input ay malisyoso. Gamitin ang "accept known good"mahusay na pagtanngap at pagkilala o ang pag validate ng input na stratehiya,i.e., gamitin ang puting listahan o whitelist para sa pagtanggap ng ng mga input na striktong sumusunod sa pagtukoy. Tanggihan ang mga input na hindi strikto sa pag conform sa pagtutukoy o sa pag transform nito sa ibang bagay na ginagawa nito. Huwag mag rely sa eksklusibon na pagtingin sa malisyosong o di maayos na input(i.e.,huwag mag rely sa itim na listahan o sa blacklist). Gayon pa man, ang itim na listahan o ang blacklist ay maaaring magamit para sa pagdetect ng potensyal na atake o sa pagtukoy ng mga inputs ay hindi maayos na maaring tanggihan agad.

Kapag ginagamit ang input na validation, iconsider na ang lahat ng potensyal na may kaugnayan sa mga properties, kasama na rito ang haba, tipo ng input, ang buong kakayahan ng pagtanggap ng halaga, kawalan o iba pang inputs, syntax, pagkakapareho sa mga parehong larangan at pagsang-ayon sa mga panuntunan sa negosyo. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as "red" or "blue."

Phase: Implementation

Be especially careful to validate your input when you invoke code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.

Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained.

Inputs should be decoded and canonicalized to the application's current internal representation before being validated. Make sure that your application does not inadvertently decode the same input twice. Such errors could be used to bypass whitelist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control.

Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.

When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.</solution>
	<reference>http://projects.webappsec.org/Improper-Input-Handling</reference>
	<reference>http://cwe.mitre.org/data/definitions/89.html</reference>
</vuln_item_wasc_20>

<vuln_items>wasc_21</vuln_items>
<vuln_item_wasc_21>
	<alert>Insufficient Anti automation</alert>
	<desc>Insufficient Anti-automation occurs when a web application permits an attacker to automate a process that was originally designed to be performed only in a manual fashion, i.e. by a human web user.

Web application functionality that is often a target for automation attacks may include:
    * Application login forms ‚Äì attackers may automate brute force login requests in an attempt to guess user credentials
    * Service registration forms ‚Äì attackers may automatically create thousands of new accounts
    * Email forms ‚Äì attackers may exploit email forms as spam relays or for flooding a certain user‚Äôs mailbox
    * Account maintenance ‚Äì attackers may perform mass DoS against an application, by flooding it with numerous requests to disable or delete user accounts
    * Account information forms ‚Äì attackers may perform mass attempts to harvest user personal information from a web application
    * Comment forms / Content Submission forms ‚Äì these may be used for spamming blogs, web forums and web bulletin boards by automatically submitting contents such as spam or even web-based malware
    * Forms tied to SQL database queries - these may be exploited in order to perform a denial of service attack against the application. The attack is performed by sending numerous heavy SQL queries in a short period of time, hence denying real users from service.
    * eShopping / eCommerce - eShopping and eCommerce applications that do not enforce human-only buyers, can be exploited in order to buy preferred items in large amounts, such as sporting events tickets. These are later sold by scalpers for higher prices.
    * Online polls - polls and other types of online voting systems can be automatically subverted in favor of a certain choice.
    * Web-based SMS message sending - attackers may exploit SMS message sending systems in order to spam mobile phone users
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Insufficient+Anti-automation</reference>
	<reference>http://cwe.mitre.org/data/definitions/116.html</reference>
</vuln_item_wasc_21>

<vuln_items>wasc_22</vuln_items>
<vuln_item_wasc_22>
	<alert>Improper Output Handling</alert>
	<desc>Output handling refers to how an application generates outgoing data.  If an application has improper output handling, the output data may be consumed leading to vulnerabilities and actions never intended by the application developer.  In many cases, this unintended interpretation is classified as one or more forms of critical application vulnerabilities.

Any location where data leaves an application boundary may be subject to improper output handling.  Application boundaries exist where data leaves one context and enters another.  This includes applications passing data to other applications via web services, sockets, command line, environmental variables, etc...  It also includes passing data between tiers within an application architecture, such as a database, directory server, HTML/JavaScript interpreter (browser), or operating system.  More detail on where improper output handling can occur can be found in the section below titled "Common Data Output Locations‚Äù.

Improper output handling may take various forms within an application.  These forms can be categorized into: protocol errors, application errors and data consumer related errors.  Protocol errors include missing or improper output encoding or escaping and outputting of invalid data.  Application errors include logic errors such as outputting incorrect data or passing on malicious content unfiltered.  If the application does not properly distinguish legitimate content from illegitimate, or does not work around known vulnerabilities in the data consumer, it may result in data-consumer abuse caused from improper output handling.

An application that does not provide data in the correct context may allow an attacker to abuse the data consumer.  This can lead to specific threats referenced within the WASC Threat Classification, including Content Spoofing, Cross-Site Scripting, HTTP Response Splitting, HTTP Response Smuggling, LDAP Injection, OS Commanding, Routing Detour, Soap Array Abuse, URL Redirector, XML Injection, XQuery Injection, XPath Injection, Mail Command Injection, Null Injection and SQL Injection.

Proper output handling prevents the unexpected or unintended interpretation of data by the consumer.  To achieve this objective, developers must understand the application's data model, how the data will be consumed by other portions of the application, and how it will ultimately be presented to the user.  Techniques for ensuring the proper handling of output include but are not limited to the filtering and sanitization of data (more detail on output sanitization and filtering can be found in appropriately titled sections below).  However, inconsistent use of selected output handling techniques may actually increase the risk of improper output handling if output data is overlooked or left untreated.  To ensure "defense in depth" developers must assume that all data within an application is untrusted when choosing appropriate output handling strategies.

While proper output handling may take many different forms, an application cannot be secure unless it protects against unintended interpretations by the data consumer. This core requirement is essential for an application to securely handle output operations.</desc>
	<solution>Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.

For example, consider using the ESAPI Encoding control or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error.

Alternately, use built-in functions, but consider using wrappers in case those functions are discovered to have a vulnerability.

Kung may magagamit o may mapapakinabangan, gamitin ang structued na mekanismo na awtomatikong mag eenforce ng separado sa pagitan ng datos at code. Ang Mekanismong ito ay maaring mag provide o maghanda ng may kaugnayan sa quoting, pag eencode at sa awtomatikong balidasyon, sa halip na umasa ang mga nag develope ang gumawa ng kapasidad o kakayahan sa lahat ng pagkakataon kapag ang output ay nagenerate.

For example, stored procedures can enforce database query structure and reduce the likelihood of SQL injection.

Understand the context in which your data will be used and the encoding that will be expected. Ito ay espesyal at importante kapag nag tatransmit o nag papasa ng datos sa pagitan ng mag kaibang components o mga sangkap. o kapag nag gegenerate ng mga output na maaaring may laman na maraming mga encoding sa parehong oras, tulad ng mga pahina sa web o sa maraming parte ng sulat at mensahe. Pag aralan ang lahat na inaasahang komyunikasyon protokol at datos ng representation na makilala o matukoy ang kinikailangang pag eencode at mga estratehiya.

In some cases, input validation may be an important strategy when output encoding is not a complete solution. For example, you may be providing the same output that will be processed by multiple consumers that use different encodings or representations. In other cases, you may be required to allow user-supplied input to contain control information, such as limited HTML tags that support formatting in a wiki or bulletin board. When this type of requirement must be met, use an extremely strict whitelist to limit which control sequences can be used. Verify that the resulting syntactic structure is what you expect. Use your normal encoding methods for the remainder of the input.

Use input validation as a defense-in-depth measure to reduce the likelihood of output encoding errors (see CWE-20).

When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.</solution>
	<reference>http://projects.webappsec.org/Improper-Output-Handling</reference>
	<reference></reference>
</vuln_item_wasc_22>

<vuln_items>wasc_23</vuln_items>
<vuln_item_wasc_23>
	<alert>XML Injection</alert>
	<desc>XML Injection is an attack technique used to manipulate or compromise the logic of an XML application or service. The injection of unintended XML content and/or structures into an XML message can alter the intend logic of the application. Further, XML injection can cause the insertion of malicious content into the resulting message/document.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/XML-Injection</reference>
	<reference></reference>
</vuln_item_wasc_23>

<vuln_items>wasc_24</vuln_items>
<vuln_item_wasc_24>
	<alert>HTTP Request Splitting</alert>
	<desc>HTTP Request Splitting is an attack that enables forcing the browser to send arbitrary HTTP requests, inflicting XSS and poisoning the browser's cache. The essence of the attack is the ability of the attacker, once the victim (browser) is forced to load the attacker's malicious HTML page, to manipulate one of the browser's functions to send 2 HTTP requests instead of one HTTP request. Two such mechanisms have been exploited to date: the XmlHttpRequest object (XHR for short) and the HTTP digest authentication mechanism. For this attack to work, the browser must use a forward HTTP proxy (not all of them "support" this attack), or the attack must be carried out against a host located on the same IP (from the browser's perspective) with the attacker's machine.</desc>
	<solution>Avoid using CRLF as a special sequence.

Appropriately filter or quote CRLF sequences in user-controlled input.</solution>
	<reference>http://projects.webappsec.org/HTTP-Request-Splitting</reference>
	<reference>http://cwe.mitre.org/data/definitions/93.html</reference>
</vuln_item_wasc_24>

<vuln_items>wasc_25</vuln_items>
<vuln_item_wasc_25>
	<alert>HTTP Response Splitting</alert>
	<desc>In the HTTP Response Splitting attack, there are always 3 parties (at least) involved:
    * Web server, which has a security hole enabling HTTP Response Splitting
    * Target - an entity that interacts with the web server perhaps on behalf of the attacker. Typically this is a cache server forward/reverse proxy), or a browser (possibly with a browser cache).
    * Attacker - initiates the attack

The essence of HTTP Response Splitting is the attacker's ability to send a single HTTP request that forces the web server to form an output stream, which is then interpreted by the target as two HTTP responses instead of one response, in the normal case. The first response may be partially controlled by the attacker, but this is less important. What is material is that the attacker completely controls the form of the second response from the HTTP status line to the last byte of the HTTP response body. Once this is possible, the attacker realizes the attack by sending two requests through the target. The first one invokes two responses from the web server, and the second request would typically be to some "innocent" resource on the web server. However, the second request would be matched, by the target, to the second HTTP response, which is fully controlled by the attacker. The attacker, therefore, tricks the target into believing that a particular resource on the web server (designated by the second request) is the server's HTTP response (server content), while it is in fact some data, which is forged by the attacker through the web server - this is the second response.

HTTP Response Splitting attacks take place where the server script embeds user data in HTTP response headers. This typically happens when the script embeds user data in the redirection URL of a redirection response (HTTP status code 3xx), or when the script embeds user data in a cookie value or name when the response sets a cookie.</desc>
	<solution>Construct HTTP headers very carefully, avoiding the use of non-validated input data.</solution>
	<reference>http://projects.webappsec.org/HTTP-Response-Splitting</reference>
	<reference>http://cwe.mitre.org/data/definitions/113.html</reference>
</vuln_item_wasc_25>

<vuln_items>wasc_26</vuln_items>
<vuln_item_wasc_26>
	<alert>HTTP Request Smuggling</alert>
	<desc>HTTP Request Smuggling is an attack technique that abuses the discrepancy in parsing of non RFC compliant HTTP requests between two HTTP devices (typically a front-end proxy or HTTP-enabled firewall and a back-end web server) to smuggle a request to the second device "through" the first device. This technique enables the attacker to send one set of requests to the second device while the first device sees a different set of requests. In turn, this facilitates several possible exploitations, such as partial cache poisoning, bypassing firewall protection and XSS.</desc>
	<solution>Use a web server that employs a strict HTTP parsing procedure, such as Apache (See paper in reference).

Use only SSL communication.

Terminate the client session after each request.

Turn all pages to non-cacheable.</solution>
	<reference>http://projects.webappsec.org/HTTP-Request-Smuggling</reference>
	<reference>http://cwe.mitre.org/data/definitions/444.html</reference>
</vuln_item_wasc_26>

<vuln_items>wasc_27</vuln_items>
<vuln_item_wasc_27>
	<alert>HTTP Response Smuggling</alert>
	<desc>HTTP response smuggling is a technique to "smuggle" 2 HTTP responses from a server to a client, through an intermediary HTTP device that expects (or allows) a single response from the server.

One use for this technique is to enhance the basic HTTP response splitting technique in order to evade anti- HTTP response splitting measures. In this case, the intermediary is the anti-HTTP response splitting mechanism between the web server and the proxy server (or web browser). Another use case is to spoof responses received by the browser. In this case a malicious web site serves the browser a page that the browser will interpret as originating from a different (target) domain. HTTP response smuggling can be used to achieve this when the browser uses a proxy server to access both sites.

HTTP response smuggling makes use of HTTP request smuggling -like techniques to exploit the discrepancies between what an anti- HTTP Response Splitting mechanism (or a proxy server) would consider to be the HTTP response stream, and the response stream as parsed by a proxy server (or a browser). So, while an anti- HTTP response splitting mechanism may consider a particular response stream harmless (single HTTP response), a proxy/browser may still parse it as two HTTP responses, and hence be susceptible to all the outcomes of the original HTTP response splitting technique (in the first use case) or be susceptible to page spoofing (in the second case). For example, some anti- HTTP response splitting mechanisms in use by some application engines forbid the application from inserting a header containing CR+LF to the response. Yet an attacker can force the application to insert a header containing CRs, thereby circumventing the defense mechanism. Some proxy servers may still treat CR (only) as a header (and response) separator, and as such the combination of web server and proxy server will still be vulnerable to an attack that may poison the proxy's cache.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/HTTP-Response-Smuggling</reference>
	<reference></reference>
</vuln_item_wasc_27>

<vuln_items>wasc_28</vuln_items>
<vuln_item_wasc_28>
	<alert>Null Byte Injection</alert>
	<desc>Null Byte Injection is an active exploitation technique used to bypass sanity checking filters in web infrastructure by adding URL-encoded null byte characters (i.e. %00, or 0x00 in hex) to the user-supplied data. This injection process can alter the intended logic of the application and allow malicious adversary to get unauthorized access to the system files.

Most web applications today are developed using higher-level languages such as, PHP, ASP, Perl, and Java. However, these web applications at some point require processing of high-level code at system level and this process is usually accomplished by using ‚ÄòC/C++‚Äô functions. The diverse nature of these dependent technologies has resulted in an attack class called ‚ÄòNull Byte Injection‚Äô or ‚ÄòNull Byte Poisoning‚Äô attack. In C/C++, a null byte represents the string termination point or delimiter character which means to stop processing the string immediately. Bytes following the delimiter will be ignored. If the string loses its null character, the length of a string becomes unknown until memory pointer happens to meet next zero byte. This unintended ramification can cause unusual behavior and introduce vulnerabilities within the system or application scope. In similar terms, several higher-level languages treat the ‚Äònull byte‚Äô as a placeholder for the string length as it has no special meaning in their context. Due to this difference in interpretation, null bytes can easily be injected to manipulate the application behavior.

URLs are limited to a set of US-ASCII characters ranging from 0x20 to 0x7E (hex) or 32 to 126 (decimal). However, the aforementioned range uses several characters that are not permitted because they have special meaning within HTTP protocol context. For this reason, the URL encoding scheme was introduced to include special characters within URL using the extended ASCII character representation. In terms of ‚Äúnull byte‚Äù, this is represented as %00 in hexadecimal. The scope of a null byte attack starts where web applications interact with active ‚ÄòC‚Äô routines and external APIs from the underlying OS. Thus, allowing an attacker to manipulate web resources by reading or writing files based on the application's user privileges.</desc>
	<solution>Developers should anticipate that null characters or null bytes will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and white lists to ensure only valid, expected and appropriate input is processed by the system.

Ipagpalagay ang lahat ng input ay malisyoso. Use a standard input validation mechanism to validate all input for length, type, syntax, and business rules before accepting the data to be displayed or stored. Use an "accept known good" validation strategy.

Use and specify a strong output encoding (such as ISO 8859-1 or UTF 8).

Do not rely exclusively on blacklist validation to detect malicious input or to encode output. There are too many variants to encode a character; you're likely to miss some variants.

Inputs should be decoded and canonicalized to the application's current internal representation before being validated. Make sure that your application does not decode the same input twice. Such errors could be used to bypass whitelist schemes by introducing dangerous inputs after they have been checked.</solution>
	<reference>http://projects.webappsec.org/Null-Byte-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/158.html</reference>
</vuln_item_wasc_28>

<vuln_items>wasc_29</vuln_items>
<vuln_item_wasc_29>
	<alert>LDAP Injection</alert>
	<desc>LDAP Injection is an attack technique used to exploit web sites that construct LDAP statements from user-supplied input.

Lightweight Directory Access Protocol (LDAP) is an open-standard protocol for both querying and manipulating X.500 directory services. The LDAP protocol runs over Internet transport protocols, such as TCP. Web applications may use user-supplied input to create custom LDAP statements for dynamic web page requests.

When a web application fails to properly sanitize user-supplied input, it is possible for an attacker to alter the construction of an LDAP statement. When an attacker is able to modify an LDAP statement, the process will run with the same permissions as the component that executed the command. (e.g. Database server, Web application server, Web server, etc.). This can cause serious security problems where the permissions grant the rights to query, modify or remove anything inside the LDAP tree. The same advanced exploitation techniques available in SQL Injection can also be similarly applied in LDAP Injection.</desc>
	<solution>Assume all input is malicious. Use an appropriate combination of black lists and white lists to neutralize LDAP syntax from user-controlled input.</solution>
	<reference>http://projects.webappsec.org/LDAP-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/90.html</reference>
</vuln_item_wasc_29>

<vuln_items>wasc_30</vuln_items>
<vuln_item_wasc_30>
	<alert>Mail Command Injection</alert>
	<desc>Mail Command Injection is an attack technique used to exploit mail servers and webmail applications that construct IMAP/SMTP statements from user-supplied input that is not properly sanitized. Depending on the type of statement taken advantage by the attacker, we meet two types of injections: IMAP and SMTP Injection. An IMAP/SMTP Injection may make it possible to access a mail server which you previously had no access to before-hand. In some cases, these internal systems do not have the same level of infrastructure security hardening applied to them as most front-end web servers. Hence, attackers may find that the mail server yields better results in terms of exploitation. On the other hand, this technique allows to evade possible restrictions that could exist at application level (CAPTCHA, maximum number of requests, etc.).</desc>
	<solution>Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, request headers as well as content, URL components, e-mail, files, databases, and any external systems that provide data to the application. Perform input validation at well-defined interfaces.

Ipagpalagay ang lahat ng input ay malisyoso. Use an "accept known good" input validation strategy (i.e., use a whitelist). Tanggihan ang mga input na hindi strikto sa pag conform sa pagtutukoy o sa pag transform nito sa ibang bagay na ginagawa nito. Use a blacklist to reject any unexpected inputs and detect potential attacks.

Do not rely exclusively on blacklist validation to detect malicious input or to encode output. There are too many ways to encode the same character, so you're likely to miss some variants.

Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained.

Inputs should be decoded and canonicalized to the application's current internal representation before being validated. Make sure that your application does not inadvertently decode the same input twice . Such errors could be used to bypass whitelist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control.

Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.

When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.

When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.</solution>
	<reference>http://projects.webappsec.org/Mail-Command-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/88.html</reference>
</vuln_item_wasc_30>

<vuln_items>wasc_31</vuln_items>
<vuln_item_wasc_31>
	<alert>OS Commanding</alert>
	<desc>OS Commanding is an attack technique used for unauthorized execution of operating system commands.

OS Commanding is the direct result of mixing trusted code and untrusted data. This attack is possible when an application accepts untrusted input to build operating system commands in an insecure manner involving improper data sanitization, and/or improper calling of external programs. In OS Commanding, executed commands by an attacker will run with the same privileges of the component that executed the command, (e.g. database server, web application server, web server, wrapper, application). Since the commands are executed under the privileges of the executing component an attacker can leverage this to gain access or damage parts that are otherwise unreachable (e.g. the operating system directories and files).</desc>
	<solution>If at all possible, use library calls rather than external processes to recreate the desired functionality.

Run your code in a "jail" or similar sandbox environment that enforces strict boundaries between the process and the operating system. Ito ay maaring epektibong restrict kung saan ang files ay pwedeng magamit sa partikular na directory o kung saan ang utos ay maaring magamit o maisagawa ng iyong software.

Ang OS-level ay mga ehemplo na kasama ang Unix chroot jail. AppArmor, at SELinux. Sa pangakalahatan, ang pag mamanage ng code ay pwedeng magbigay ng ilang proteksyon. Halimbawa, java.io FilePermission sa mga Java SecurityManager na mag aallow sayo ng pagtukoy sa mga restrictions o sa mga mahigpit na file na operasyon.
Ito ay maaring di magawan ng solusyon, at ito ay limitasyon sa pag impact ng mga sitemang nag ooperate; at ang lahat ng iyong aplikasyon ay maaring maging paksa para sa kompormiso.

For any data that will be used to generate a command to be executed, keep as much of that data out of external control as possible. For example, in web applications, this may require storing the command locally in the session's state instead of sending it out to the client in a hidden form field.

Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.

For example, consider using the ESAPI Encoding control or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error.

If you need to use dynamically-generated query strings or commands in spite of the risk, properly quote arguments and escape any special characters within those arguments. Ang pinaka-konserbatibong paraan ay upang makawala o mag-sala ng lahat ng mga character na hindi nakapasa sa isang lubos na mahigpit na whitelist (tulad ng lahat ng bagay na hindi alphanumeric o puting patlang). Kung kinakailangan ng mo ng ilang mga espesyal na character, tulad ng puting patlang, balutin ang bawat argumento sa mga panipi pagkatapos ng pagtakas/hakbang sa pagsala. Be careful of argument injection.

If the program to be executed allows arguments to be specified within an input file or from standard input, then consider using that mode to pass arguments instead of the command line.

Kung may magagamit o may mapapakinabangan, gamitin ang structued na mekanismo na awtomatikong mag eenforce ng separado sa pagitan ng datos at code. Ang Mekanismong ito ay maaring mag provide o maghanda ng may kaugnayan sa quoting, pag eencode at sa awtomatikong balidasyon, sa halip na umasa ang mga nag develope ang gumawa ng kapasidad o kakayahan sa lahat ng pagkakataon kapag ang output ay nagenerate.

Some languages offer multiple functions that can be used to invoke commands. Where possible, identify any function that invokes a command shell using a single string, and replace it with a function that requires individual arguments. These functions typically perform appropriate quoting and filtering of arguments. For example, in C, the system() function accepts a string that contains the entire command to be executed, whereas execl(), execve(), and others require an array of strings, one for each argument. In Windows, CreateProcess() only accepts one command at a time. In Perl, if system() is provided with an array of arguments, then it will quote each of the arguments.

Ipagpalagay ang lahat ng input ay malisyoso. Gamitin ang "accept known good"mahusay na pagtanngap at pagkilala o ang pag validate ng input na stratehiya,i.e., gamitin ang puting listahan o whitelist para sa pagtanggap ng ng mga input na striktong sumusunod sa pagtukoy. Tanggihan ang mga input na hindi strikto sa pag conform sa pagtutukoy o sa pag transform nito sa ibang bagay na ginagawa nito. Huwag mag rely sa eksklusibon na pagtingin sa malisyosong o di maayos na input(i.e.,huwag mag rely sa itim na listahan o sa blacklist). Gayon pa man, ang itim na listahan o ang blacklist ay maaaring magamit para sa pagdetect ng potensyal na atake o sa pagtukoy ng mga inputs ay hindi maayos na maaring tanggihan agad.

Kapag ginagamit ang input na validation, iconsider na ang lahat ng potensyal na may kaugnayan sa mga properties, kasama na rito ang haba, tipo ng input, ang buong kakayahan ng pagtanggap ng halaga, kawalan o iba pang inputs, syntax, pagkakapareho sa mga parehong larangan at pagsang-ayon sa mga panuntunan sa negosyo. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as "red" or "blue."

When constructing OS command strings, use stringent whitelists that limit the character set based on the expected value of the parameter in the request. Ito ay hindi direktang nalilimitahan ang sakop ng isang pag-atake, subalit ang pamamaraan na ito ay mas mahalaga kaysa sa tamang pag-pasok ng output at pag-alis.

Note that proper output encoding, escaping, and quoting is the most effective solution for preventing OS command injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent OS command injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, when invoking a mail program, you might need to allow the subject field to contain otherwise-dangerous inputs like ";" and ">" characters, which would need to be escaped or otherwise handled. In this case, stripping the character might reduce the risk of OS command injection, but it would produce incorrect behavior because the subject field would not be recorded as the user intended. This might seem to be a minor inconvenience, but it could be more important when the program relies on well-structured subject lines in order to pass messages to other components.

Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.</solution>
	<reference>http://projects.webappsec.org/OS-Commanding</reference>
	<reference>http://cwe.mitre.org/data/definitions/78.html</reference>
</vuln_item_wasc_31>

<vuln_items>wasc_32</vuln_items>
<vuln_item_wasc_32>
	<alert>Routing Detour</alert>
	<desc>The WS-Routing Protocol (WS-Routing) is a protocol for exchanging SOAP messages from an initial message sender to an ultimate receiver, typically via a set of intermediaries. The WS-Routing protocol is implemented as a SOAP extension, and is embedded in the SOAP Header. WS-Routing is often used to provide a way to direct XML traffic through complex environments and transactions by allowing interim way stations in the XML path to assign routing instructions to an XML document.

Routing Detours are a type of "Man in the Middle" attack where Intermediaries can be injected or "hijacked" to route sensitive messages to an outside location. Routing information (either in the HTTP header or in WS-Routing header) can be modified en route and traces of the routing can be removed from the header and message such that the receiving application none the wiser that a routing detour has occurred. The header and the insertion of header objects is often less protected than the message; this is due to the fact that the header is used as a catch all for metadata about the transaction such as authentication, routing, formatting, schema, canonicalization, namespaces, etc. Also, many processes may be involved in adding to/processing the header of an XML document. In many implementations the routing info can come from an external web service (using WS-Referral for example) that provides the specific routing for the transaction.

WS-Addressing is a newer standard published by the W3C to provide routing functionality to SOAP messages. One of the key differences between WS-Routing and WS-Addressing is that WS-Addressing only provides the next location in the route. While little research has been done into the susceptibility of WS-Addressing to Routing Detour Attack, at least one paper (see reference #6 below) suggests that WS-Addressing is vulnerable to Routing Detour as well.</desc>
	<solution>Always fully authenticate both ends of any communications channel.

Adhere to the principle of complete mediation.

A certificate binds an identity to a cryptographic key to authenticate a communicating party. Often, the certificate takes the encrypted form of the hash of the identity of the subject, the public key, and information such as time of issue or expiration using the issuer's private key. The certificate can be validated by deciphering the certificate with the issuer's public key. See also X.509 certificate signature chains and the PGP certification structure.</solution>
	<reference>http://projects.webappsec.org/Routing-Detour</reference>
	<reference>http://cwe.mitre.org/data/definitions/300.html</reference>
</vuln_item_wasc_32>

<vuln_items>wasc_33</vuln_items>
<vuln_item_wasc_33>
	<alert>Path Traversal</alert>
	<desc>The Path Traversal attack technique allows an attacker access to files, directories, and commands that potentially reside outside the web document root directory. An attacker may manipulate a URL in such a way that the web site will execute or reveal the contents of arbitrary files anywhere on the web server. Any device that exposes an HTTP-based interface is potentially vulnerable to Path Traversal.

Most web sites restrict user access to a specific portion of the file-system, typically called the "web document root" or "CGI root" directory. These directories contain the files intended for user access and the executable necessary to drive web application functionality. To access files or execute commands anywhere on the file-system, Path Traversal attacks will utilize the ability of special-characters sequences.

The most basic Path Traversal attack uses the "../" special-character sequence to alter the resource location requested in the URL. Although most popular web servers will prevent this technique from escaping the web document root, alternate encodings of the "../" sequence may help bypass the security filters. These method variations include valid and invalid Unicode-encoding ("..%u2216" or "..%c0%af") of the forward slash character, backslash characters ("..\") on Windows-based servers, URL encoded characters "%2e%2e%2f"), and double URL encoding ("..%255c") of the backslash character.

Even if the web server properly restricts Path Traversal attempts in the URL path, a web application itself may still be vulnerable due to improper handling of user-supplied input. This is a common problem of web applications that use template mechanisms or load static text from files. In variations of the attack, the original URL parameter value is substituted with the file name of one of the web application's dynamic scripts. Consequently, the results can reveal source code because the file is interpreted as text instead of an executable script. These techniques often employ additional special characters such as the dot (".") to reveal the listing of the current working directory, or "%00" NULL characters in order to bypass rudimentary file extension checks.</desc>
	<solution>Ipagpalagay ang lahat ng input ay malisyoso. Gamitin ang "accept known good"mahusay na pagtanngap at pagkilala o ang pag validate ng input na stratehiya,i.e., gamitin ang puting listahan o whitelist para sa pagtanggap ng ng mga input na striktong sumusunod sa pagtukoy. Tanggihan ang mga input na hindi strikto sa pag conform sa pagtutukoy o sa pag transform nito sa ibang bagay na ginagawa nito. Huwag mag rely sa eksklusibon na pagtingin sa malisyosong o di maayos na input(i.e.,huwag mag rely sa itim na listahan o sa blacklist). Gayon pa man, ang itim na listahan o ang blacklist ay maaaring magamit para sa pagdetect ng potensyal na atake o sa pagtukoy ng mga inputs ay hindi maayos na maaring tanggihan agad.

Kapag ginagamit ang input na validation, iconsider na ang lahat ng potensyal na may kaugnayan sa mga properties, kasama na rito ang haba, tipo ng input, ang buong kakayahan ng pagtanggap ng halaga, kawalan o iba pang inputs, syntax, pagkakapareho sa mga parehong larangan at pagsang-ayon sa mga panuntunan sa negosyo. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as "red" or "blue."

For filenames, use stringent whitelists that limit the character set to be used. If feasible, only allow a single "." character in the filename to avoid weaknesses, and exclude directory separators such as "/". Use a whitelist of allowable file extensions.

Warning: if you attempt to cleanse your data, then do so that the end result is not in the form that can be dangerous. A sanitizing mechanism can remove characters such as '.' and ';' which may be required for some exploits. An attacker can try to fool the sanitizing mechanism into "cleaning" data into a dangerous form. Suppose the attacker injects a '.' inside a filename (e.g. "sensi.tiveFile") and the sanitizing mechanism removes the character resulting in the valid filename, "sensitiveFile". If the input data are now assumed to be safe, then the file may be compromised. 

Inputs should be decoded and canonicalized to the application's current internal representation before being validated. Make sure that your application does not decode the same input twice. Such errors could be used to bypass whitelist schemes by introducing dangerous inputs after they have been checked.

Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes ".." sequences and symbolic links.

Run your code using the lowest privileges that are required to accomplish the necessary tasks. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.

When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.

Run your code in a "jail" or similar sandbox environment that enforces strict boundaries between the process and the operating system. Ito ay maaring epektibong restrict kung saan ang files ay pwedeng magamit sa partikular na directory o kung saan ang utos ay maaring magamit o maisagawa ng iyong software.

Ang OS-level ay mga ehemplo na kasama ang Unix chroot jail. AppArmor, at SELinux. Sa pangakalahatan, ang pag mamanage ng code ay pwedeng magbigay ng ilang proteksyon. Halimbawa, java.io FilePermission sa mga Java SecurityManager na mag aallow sayo ng pagtukoy sa mga restrictions o sa mga mahigpit na file na operasyon.

Ito ay maaring di magawan ng solusyon, at ito ay limitasyon sa pag impact ng mga sitemang nag ooperate; at ang lahat ng iyong aplikasyon ay maaring maging paksa para sa kompormiso.
</solution>
	<reference>http://projects.webappsec.org/Path-Traversal</reference>
	<reference>http://cwe.mitre.org/data/definitions/22.html</reference>
</vuln_item_wasc_33>

<vuln_items>wasc_34</vuln_items>
<vuln_item_wasc_34>
	<alert>Predictable Resource Location</alert>
	<desc>Predictable Resource Location is an attack technique used to uncover hidden web site content and functionality. By making educated guesses via brute forcing an attacker can guess file and directory names not intended for public viewing. Brute forcing filenames is easy because files/paths often have common naming convention and reside in standard locations. These can include temporary files, backup files, logs, administrative site sections, configuration files, demo applications, and sample files. These files may disclose sensitive information about the website, web application internals, database information, passwords, machine names, file paths to other sensitive areas, etc...

This will not only assist with identifying site surface which may lead to additional site vulnerabilities, but also may disclose valuable information to an attacker about the environment or its users. Predictable Resource Location is also known as Forced Browsing, Forceful Browsing, File Enumeration, and Directory Enumeration.</desc>
	<solution>Apply appropriate access control authorizations for each access to all restricted URLs, scripts or files.

Consider using MVC based frameworks such as Struts.</solution>
	<reference>http://projects.webappsec.org/Predictable-Resource-Location</reference>
	<reference>http://cwe.mitre.org/data/definitions/425.html</reference>
</vuln_item_wasc_34>

<vuln_items>wasc_35</vuln_items>
<vuln_item_wasc_35>
	<alert>SOAP Array Abuse</alert>
	<desc>XML SOAP arrays are a common target for malicious abuse. SOAP arrays are defined as having a type of "SOAP-ENC:Array" or a type derived there from. SOAP arrays have one or more dimensions (rank) whose members are distinguished by ordinal position. An array value is represented as a series of elements reflecting the array, with members appearing in ascending ordinal sequence. For multi-dimensional arrays the dimension on the right side varies most rapidly. Each member element is named as an independent element. A web-service that expects an array can be the target of a XML DoS attack by forcing the SOAP server to build a huge array in the machine's memory, thus inflicting a DoS condition on the machine due to the memory pre-allocation.</desc>
	<solution> Perform adequate input validation against any value that influences the amount of memory that is allocated. Define an appropriate strategy for handling requests that exceed the limit, and consider supporting a configuration option so that the administrator can extend the amount of memory to be used if necessary.

Run your program using system-provided resource limits for memory. This might still cause the program to crash or exit, but the impact to the rest of the system will be minimized.</solution>
	<reference>http://projects.webappsec.org/SOAP-Array-Abuse</reference>
	<reference>http://cwe.mitre.org/data/definitions/789.html</reference>
</vuln_item_wasc_35>

<vuln_items>wasc_36</vuln_items>
<vuln_item_wasc_36>
	<alert>SSI Injection</alert>
	<desc>SSI Injection (Server-side Include) is a server-side exploit technique that allows an attacker to send code into a web application, which will later be executed locally by the web server. SSI Injection exploits a web application's failure to sanitize user-supplied data before they are inserted into a server-side interpreted HTML file.

Before serving an HTML web page, a web server may parse and execute Server-side Include statements before providing it to the client. In some cases (e.g. message boards, guest books, or content management systems), a web application will insert user-supplied data into the source of a web page.

If an attacker submits a Server-side Include statement, he may have the ability to execute arbitrary operating system commands, or include a restricted file's contents the next time the page is served. This is performed at the permission level of the web server user.</desc>
	<solution>Disable SSI execution on pages that do not require it. For pages requiring SSI ensure that you perform the following checks
- Only enable the SSI directives that are needed for this page and disable all others.
- HTML entity encode user supplied data before passing it to a page with SSI execution permissions.
- Use SUExec to have the page execute as the owner of the file instead of the web server user.</solution>
	<reference>http://projects.webappsec.org/SSI-Injection</reference>
	<reference></reference>
</vuln_item_wasc_36>

<vuln_items>wasc_37</vuln_items>
<vuln_item_wasc_37>
	<alert>Session Fixation</alert>
	<desc>Session Fixation is an attack technique that forces a user's session ID to an explicit value. Depending on the functionality of the target web site, a number of techniques can be utilized to "fix" the session ID value. These techniques range from Cross-site Scripting exploits to peppering the web site with previously made HTTP requests. After a user's session ID has been fixed, the attacker will wait for that user to login. Once the user does so, the attacker uses the predefined session ID value to assume the same online identity.

Generally speaking there are two types of session management systems when it comes to ID values. The first type is "permissive" systems that allow web browsers to specify any ID. The second type is "strict" systems that only accept server-side-generated values. With permissive systems, arbitrary session IDs are maintained without contact with the web site. Strict systems require the attacker to maintain the "trap-session", with periodic web site contact, preventing inactivity timeouts.

Without active protection against Session Fixation, the attack can be mounted against any web site that uses sessions to identify authenticated users. Web sites using sessions IDs are normally cookie-based, but URLs and hidden form fields are used as well. Unfortunately, cookie-based sessions are the easiest to attack. Most of the currently identified attack methods are aimed toward the fixation of cookies.

In contrast to stealing a users' session IDs after they have logged into a web site, Session Fixation provides a much wider window of opportunity. The active part of the attack takes place before a user logs in.</desc>
	<solution>Invalidate any existing session identifiers prior to authorizing a new user session

For platforms such as ASP that do not generate new values for sessionid cookies, utilize a secondary cookie. In this approach, set a secondary cookie on the user's browser to a random value and set a session variable to the same value. If the session variable and the cookie value ever don't match, invalidate the session, and force the user to log on again.</solution>
	<reference>http://projects.webappsec.org/Session-Fixation</reference>
	<reference>http://cwe.mitre.org/data/definitions/384.html</reference>
</vuln_item_wasc_37>

<vuln_items>wasc_38</vuln_items>
<vuln_item_wasc_38>
	<alert>URL Redirector Abuse</alert>
	<desc>URL redirectors represent common functionality employed by web sites to forward an incoming request to an alternate resource. This can be done for a variety of reasons and is often done to allow resources to be moved within the directory structure and to avoid breaking functionality for users that request the resource at its previous location. URL redirectors may also be used to implement load balancing, leveraging abbreviated URLs or recording outgoing links. It is this last implementation which is often used in phishing attacks as described in the example below. URL redirectors do not necessarily represent a direct security vulnerability but can be abused by attackers trying to social engineer victims into believing that they are navigating to a site other than the true destination.</desc>
	<solution>Ipagpalagay ang lahat ng input ay malisyoso. Gamitin ang "accept known good"mahusay na pagtanngap at pagkilala o ang pag validate ng input na stratehiya,i.e., gamitin ang puting listahan o whitelist para sa pagtanggap ng ng mga input na striktong sumusunod sa pagtukoy. Tanggihan ang mga input na hindi strikto sa pag conform sa pagtutukoy o sa pag transform nito sa ibang bagay na ginagawa nito. Huwag mag rely sa eksklusibon na pagtingin sa malisyosong o di maayos na input(i.e.,huwag mag rely sa itim na listahan o sa blacklist). Gayon pa man, ang itim na listahan o ang blacklist ay maaaring magamit para sa pagdetect ng potensyal na atake o sa pagtukoy ng mga inputs ay hindi maayos na maaring tanggihan agad.

Kapag ginagamit ang input na validation, iconsider na ang lahat ng potensyal na may kaugnayan sa mga properties, kasama na rito ang haba, tipo ng input, ang buong kakayahan ng pagtanggap ng halaga, kawalan o iba pang inputs, syntax, pagkakapareho sa mga parehong larangan at pagsang-ayon sa mga panuntunan sa negosyo. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as "red" or "blue."

Use a whitelist of approved URLs or domains to be used for redirection.

Use an intermediate disclaimer page that provides the user with a clear warning that they are leaving your site. Implement a long timeout before the redirect occurs, or force the user to click on the link. Be careful to avoid XSS problems when generating the disclaimer page.

When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.

For example, ID 1 could map to "/login.asp" and ID 2 could map to "http://www.example.com/". Ang mga tampok kapareho ng ESAPI AccessReferenceMap ay naglalaan ng kakayahan na ito.

Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, databases, and any external systems that provide data to the application. Tandaan na ang mga ganong input ay maaaring hindi direktang makuha sa pamamagitan ng mga API call.

Many open redirect problems occur because the programmer assumed that certain inputs could not be modified, such as cookies and hidden form fields.</solution>
	<reference>http://projects.webappsec.org/URL-Redirector-Abuse</reference>
	<reference>http://cwe.mitre.org/data/definitions/601.html</reference>
</vuln_item_wasc_38>

<vuln_items>wasc_39</vuln_items>
<vuln_item_wasc_39>
	<alert>XPath Injection</alert>
	<desc>XPath Injection is an attack technique used to exploit applications that construct XPath (XML Path Language) queries from user-supplied input to query or navigate XML documents. It can be used directly by an application to query an XML document, as part of a larger operation such as applying an XSLT transformation to an XML document, or applying an XQuery to an XML document. The syntax of XPath bears some resemblance to an SQL query, and indeed, it is possible to form SQL-like queries on an XML document using XPath.

If an application uses run-time XPath query construction, embedding unsafe user input into the query, it may be possible for the attacker to inject data into the query such that the newly formed query will be parsed in a way differing from the programmer's intention.</desc>
	<solution>Use parameterized XPath queries (e.g. using XQuery). This will help ensure separation between data plane and control plane.

Properly validate user input. Reject data where appropriate, filter where appropriate and escape where appropriate. Make sure input that will be used in XPath queries is safe in that context.</solution>
	<reference>http://projects.webappsec.org/XPath-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/643.html</reference>
</vuln_item_wasc_39>

<vuln_items>wasc_40</vuln_items>
<vuln_item_wasc_40>
	<alert>Insufficient Process Validation</alert>
	<desc>Insufficient Process Validation occurs when a web application fails to prevent an attacker from circumventing the intended flow or business logic of the application. When seen in the real world, insufficient process validation has resulted in ineffective access controls and monetary loss.

There are two main types of processes that require validation: flow control and business logic.

"Flow control" refers to multi-step processes that require each step to be performed in a specific order by the user. When an attacker performs the step incorrectly or out of order, the access controls may be bypassed and an application integrity error may occur. Examples of multi-step processes include wire transfer, password recovery, purchase checkout, and account sign-up.

"Business logic" refers to the context in which a process will execute as governed by the business requirements. Exploiting a business logic weakness requires knowledge of the business; if no knowledge is needed to exploit it, then most likely it isn't a business logic flaw. Due to this, typical security measures such as scans and code review will not find this class of weakness. One approach to testing is offered by OWASP in their Testing Guide.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Insufficient-Process-Validation</reference>
	<reference></reference>
</vuln_item_wasc_40>

<vuln_items>wasc_41</vuln_items>
<vuln_item_wasc_41>
	<alert>XML Attribute Blowup</alert>
	<desc>XML Attribute Blowup is a denial of service attack against XML parsers. The attacker provides a malicious XML document, which vulnerable XML parsers process in a very inefficient manner, leading to excessive CPU load. The essence of the attack is to include many attributes in the same XML node. Vulnerable XML parsers manage the attributes in an inefficient manner (e.g. in a data container for which insertion of a new attribute has O(n) runtime), resulting in a non-linear (in this example, quadratic, i.e. O(n2)) overall runtime, leading to a denial of service condition via CPU exhaustion.</desc>
	<solution>Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.

Mitigation of resource exhaustion attacks requires that the target system either:
 * recognizes the attack and denies that user further access for a given amount of time, or
 * uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed. 

The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, he may be able to prevent the user from accessing the server in question.

The second solution is simply difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply makes the attack require more resources on the part of the attacker.

Ensure that protocols have specific limits of scale placed on them.

Ensure that all failures in resource allocation place the system into a safe posture.</solution>
	<reference>http://projects.webappsec.org/XML-Attribute-Blowup</reference>
	<reference>http://cwe.mitre.org/data/definitions/400.html</reference>
</vuln_item_wasc_41>

<vuln_items>wasc_42</vuln_items>
<vuln_item_wasc_42>
	<alert>Abuse of Functionality</alert>
	<desc>Abuse of Functionality is an attack technique that uses a web site's own features and functionality to attack itself or others. Abuse of Functionality can be described as the abuse of an application's intended functionality to perform an undesirable outcome. These attacks have varied results such as consuming resources, circumventing access controls, or leaking information. The potential and level of abuse will vary from web site to web site and application to application. Abuse of functionality attacks are often a combination of other attack types and/or utilize other attack vectors.</desc>
	<solution>Always utilize APIs in the specified manner.</solution>
	<reference>http://projects.webappsec.org/Abuse-of-Functionality</reference>
	<reference>http://cwe.mitre.org/data/definitions/227.html</reference>
</vuln_item_wasc_42>

<vuln_items>wasc_43</vuln_items>
<vuln_item_wasc_43>
	<alert>XML External Entities</alert>
	<desc>This technique takes advantage of a feature of XML to build documents dynamically at the time of processing. An XML message can either provide data explicitly or by pointing to an URI where the data exists. In the attack technique, external entities may replace the entity value with malicious data, alternate referrals or may compromise the security of the data the server/XML application has access to.
	Attackers may also use External Entities to have the web services server download malicious code or content to the server for use in secondary or follow on attacks.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/XML-External-Entities</reference>
	<reference></reference>
</vuln_item_wasc_43>

<vuln_items>wasc_44</vuln_items>
<vuln_item_wasc_44>
	<alert>XML Entity Expansion</alert>
	<desc>The XML Entity expansion attack, exploits a capability in XML DTDs that allows the creation of custom macros, called entities, that can be used throughout a document. By recursively defining a set of custom entities at the top of a document, an attacker can overwhelm parsers that attempt to completely resolve the entities by forcing them to iterate almost indefinitely on these recursive definitions.

The malicious XML message is used to force recursive entity expansion (or other repeated processing) that completely uses up available server resources.</desc>
	<solution>If possible, prohibit the use of DTDs or use an XML parser that limits the expansion of recursive DTD entities.

Before parsing XML files with associated DTDs, scan for recursive entity declarations and do not continue parsing potentially explosive content.</solution>
	<reference>http://projects.webappsec.org/XML-Entity-Expansion</reference>
	<reference>http://cwe.mitre.org/data/definitions/776.html</reference>
</vuln_item_wasc_44>

<vuln_items>wasc_45</vuln_items>
<vuln_item_wasc_45>
	<alert>Fingerprinting</alert>
	<desc>The most common methodology for attackers is to first footprint the target's web presence and enumerate as much information as possible. With this information, the attacker may develop an accurate attack scenario, which will effectively exploit a vulnerability in the software type/version being utilized by the target host.

Multi-tier fingerprinting is similar to its predecessor, TCP/IP Fingerprinting (with a scanner such as Nmap) except that it is focused on the Application Layer of the OSI model instead of the Transport Layer. The theory behind this fingerprinting is to create an accurate profile of the target's platform, web application software technology, backend database version, configurations and possibly even their network architecture/topology.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Fingerprinting</reference>
	<reference></reference>
</vuln_item_wasc_45>

<vuln_items>wasc_46</vuln_items>
<vuln_item_wasc_46>
	<alert>XQuery Injection</alert>
	<desc>XQuery Injection is a variant of the classic SQL injection attack against the XML XQuery Language. XQuery Injection uses improperly validated data that is passed to XQuery commands. This inturn will execute commands on behalf of the attacker that the XQuery routines have access to. XQuery injection can be used to enumerate elements on the victim's environment, inject commands to the local host, or execute queries to remote files and data sources. Like SQL injection attacks, the attacker tunnels through the application entry point to target the resource access layer.</desc>
	<solution>Use parameterized queries. This will help ensure separation between data plane and control plane.

Properly validate user input. Reject data where appropriate, filter where appropriate and escape where appropriate. Make sure input that will be used in XQL queries is safe in that context.</solution>
	<reference>http://projects.webappsec.org/XQuery-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/652.html</reference>
</vuln_item_wasc_46>

<vuln_items>wasc_47</vuln_items>
<vuln_item_wasc_47>
	<alert>Insufficient Session Expiration</alert>
	<desc>Insufficient Session Expiration occurs when a Web application permits an attacker to reuse old session credentials or session IDs for authorization. Insufficient Session Expiration increases a Web site's exposure to attacks that steal or reuse user's session identifiers.

Since HTTP is a stateless protocol, Web sites commonly use cookies to store session IDs that uniquely identify a user from request to request. Consequently, each session ID's confidentiality must be maintained in order to prevent multiple users from accessing the same account. A stolen session ID can be used to view another user's account or perform a fraudulent transaction.

Session expiration is comprised of two timeout types: inactivity and absolute. An absolute timeout is defined by the total amount of time a session can be valid without re-authentication and an inactivity timeout is the amount of idle time allowed before the session is invalidated. The lack of proper session expiration may increase the likelihood of success of certain attacks. A long expiration time increases an attacker's chance of successfully guessing a valid session ID. The longer the expiration time, the more concurrent open sessions will exist at any given time. The larger the pool of sessions, the more likely it will be for an attacker to guess one at random. Although a short session inactivity timeout does not help if a token is immediately used, the short timeout helps to insure that the token is harder to capture while it is still valid.

A Web application should invalidate a session after a predefined idle time has passed (a timeout) and provide the user the means to invalidate their own session, i.e. logout; this helps to keep the lifespan of a session ID as short as possible and is necessary in a shared computing environment where more than one person has unrestricted physical access to a computer. The logout function should be prominently visible to the user, explicitly invalidate a user‚Äôs session and disallow reuse of the session token.</desc>
	<solution>Set sessions/credentials expiration date.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Session-Expiration</reference>
	<reference>http://cwe.mitre.org/data/definitions/613.html</reference>
</vuln_item_wasc_47>

<vuln_items>wasc_48</vuln_items>
<vuln_item_wasc_48>
	<alert>Insecure Indexing</alert>
	<desc>Insecure Indexing is a threat to the data confidentiality of the web-site. Indexing web-site contents via a process that has access to files which are not supposed to be publicly accessible has the potential of leaking information about the existence of such files, and about their content. In the process of indexing, such information is collected and stored by the indexing process, which can later be retrieved (albeit not trivially) by a determined attacker, typically through a series of queries to the search engine. The attacker does not thwart the security model of the search engine. As such, this attack is subtle and very hard to detect and to foil - it‚Äôs not easy to distinguish the attacker‚Äôs queries from a legitimate user‚Äôs queries.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Insecure-Indexing</reference>
	<reference></reference>
</vuln_item_wasc_48>

<vuln_items>wasc_49</vuln_items>
<vuln_item_wasc_49>
	<alert>Insufficient Password Recovery</alert>
	<desc>Insufficient Password Recovery is when a web site permits an attacker to illegally obtain, change or recover another user's password. Conventional web site authentication methods require users to select and remember a password or passphrase. The user should be the only person that knows the password and it must be remembered precisely. As time passes, a user's ability to remember a password fades. The matter is further complicated when the average user visits 20 sites requiring them to supply a password.  (RSA Survey: http://news.bbc.co.uk/1/hi/technology/3639679.stm) Thus, password recovery is an important part in servicing online users.

Examples of automated password recovery processes include requiring the user to answer a "secret question" defined as part of the user registration process. This question can either be selected from a list of canned questions or supplied by the user. Another mechanism in use is having the user provide a "hint" during registration that will help the user remember his password. Other mechanisms require the user to provide several pieces of personal data such as their social security number, home address, zip code etc. to validate their identity. After the user has proven who they are, the recovery system will display or e-mail them a new password.

A web site is considered to have Insufficient Password Recovery when an attacker is able to foil the recovery mechanism being used. This happens when the information required to validate a user's identity for recovery is either easily guessed or can be circumvented. Password recovery systems may be compromised through the use of brute force attacks, inherent system weaknesses, or easily guessed secret questions.</desc>
	<solution>Make sure that all input supplied by the user to the password recovery mechanism is thoroughly filtered and validated

Do not use standard weak security questions and use several security questions.

Make sure that there is throttling on the number of incorrect answers to a security question. Disable the password recovery functionality after a certain (small) number of incorrect guesses.

Require that the user properly answers the security question prior to resetting their password and sending the new password to the e-mail address of record.

Never allow the user to control what e-mail address the new password will be sent to in the password recovery mechanism.

Assign a new temporary password rather than revealing the original password.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Password-Recovery</reference>
	<reference>http://cwe.mitre.org/data/definitions/640.html</reference>
</vuln_item_wasc_49>

</vulnerabilities>