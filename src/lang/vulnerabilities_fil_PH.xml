<?xml version="1.0" encoding="utf-8" ?>
<vulnerabilities xmlns="http://tempuri.org/XMLSchemaOptions.xsd">

<vuln_items>wasc_1</vuln_items>
<vuln_item_wasc_1>
	<alert>Hindi sapat na nagpapatunay</alert>
	<desc>Hindi sapat na nagpapatunay ay nangyayari kapag ang isang web site ay nagpapahintulot sa attacker na ma-access ang sensitibo o functionality nang hindi na kinakailangang mapatunayan ng wasto. Web-based na administrasyon na mga gamit ay isang magandang halimbawa ng mga web sites na pagbibigay ng access sa sensitibong pag-andar. Depende sa partikular na online na pagkukunan, ang mga web applications ay hindi dapat direktang naa-access nang hindi nangangailangan ng gumagamit upang maayos na mapatunayan ang kanilang pagkakakilanlan.

Upang makakuha sa paligid ng pag-set up sa authentication, ilang resources ay hindi protektado ng "pagtatago" ang tiyak na lokasyon at hindi nag-uugnay sa lokasyon sa pangunahing web site o iba pang mga pampublikong lugar. Gayunpaman, ang paraang ito ay hindi higit kaya sa mga "Security Through Obscurity". Ito ay mahalaga na maunawaan na kahit na isang resource na ito ay hindi kilala sa attacker, ito pa rin ay nanatiling magagamit ng direkta sa isang partikular na URL. Ang partikular na URL ay mangyaring natuklasan sa pamamagitan ng isang Brute Force na paraan para sa mga common file at mga lokasyon ng direktoryo (/admin para sa halimbawa), ang mga maling mensahe, referrer logs, o dokumento tulad ng mga help files. Ang mga pagkukunan, kung sila ay nilalaman o pagpapagana-hinihimok, dapat sapat protektado.</desc>
	<solution>Yugto: Arkitektura at Disenyo
Gamitin ang pagpapatunay na framework o library na tulad ng OWASP ESAPI Authentication feature.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Authentication</reference>
	<reference>http://cwe.mitre.org/data/definitions/287.html</reference>
	<reference>http://cwe.mitre.org/data/definitions/284.html</reference>
</vuln_item_wasc_1>

<vuln_items>wasc_2</vuln_items>
<vuln_item_wasc_2>
	<alert>Hindi sapat na pagpapatunay</alert>
	<desc>Hindi sapat na pagpagtunay na mga resulta kapag ang isang application ay hindi nagsasagawa ng sapat na pahintulot upang matiyak ang pagsasagawa ng gumagamit o pag-access ng datos sa paraang naayos sa patakaran sa seguridad. Mga pagpapahintulot na mga procedure ay dapat ipapatupad kung anong user, serbisyo o aplikasyon ay pinahintulutang gawin. Nang ang gumamit ay mapagtibay sa isang web site, ito ay hindi nangangahulugan na ang mga gumagamit ay dapat magkaroon ng full access sa lahat ng nilalaman at mga functionality.

Hindi sapat ang Function Authorization

Maraming mga applications ang pinagkaloob ng iba't ibang mga aplikasyon functionality ng iba't ibang mga gumagamit. Isang news site na ito ay nagpapahintulot sa mga gumagamit na makita ang mga kuwento ng balita, pero hindi na ilathala sa kanila. Isang accounting na sistema ay nagkakaroon ng iba't ibang mga pahintulot para sa isang Accounts Payable clerk at isang Accounts Receivable clerk. Kulang ang kakayahan ng awtorisasyon ay nangyayari kapag ang isang aplikasyon ay hindi pumipigil sa mga taga-gamit na ma-dagdag ang pag-andar ng aplikasyon na lumalabag sa patakaran sa katiwasayan.

Isang malinaw na halimbawa ay ang 2005 na pag-hack ng proseso ng aplikasyon ng Harvard Business School. An authorization failure allowed users to view their own data when they should not have been allowed to access that part of the web site.
 
Hindi sapat na Data Authorization

Maraming mga applications ang inilantad na batayan ng pagkakailan sa isang URL. Halimbawa, kapag ina-access ang isang medikal na talaan sa isang sistema ng isa ay magkaroon ng isang URL tulad ng:

http://example.com/RecordView?id=12345

Kung ang aplikasyon ay hindi sunusuri na yung mga naka-authenticated na user ID ay mayroong karapatan sa pagbasa, at pagkatapos ay maidispley itong mga datos para sa gumagamit ay dapat hindi makita.

Hindi sapat na Data Authorization ay mas karaniwan kaya sa hindi sapat na Function Authorization dahil ang mga programmer karaniwang nagkaroon ng kumpletong kaalaman sa functionality ng aplikasyon, ngunit hindi laging may isang kumpletong mapping ng lahat ng data na ma-access ang mga aplikasyon. Mga programmer ay madalas magkaroon ng mahigpit na kontrol sa mga function authorization mechanisms, ngunit umaasa sa iba pang mga sistema tulad ng mga database upang masagawa ang pahintulot ng datos.</desc>
	<solution>Yugto: Arkitektura at Disenyo; Operasyon ay mabuting pinamahala ang settings, management, at paghawak ng mga pribilehiyo. Malinaw na pagpapangasiwa ng mga trust zones sa software.

Yugto: Arkitektura at Disenyo
Pagsiguro na ang nararapat na compartmentalization ay naitayo into sa sistema ng disenyo at na ang compartmentalization ay nagbibigay pahintulot para sa pagpapalakas ng pahintulot sa separation functionality. Mga arkitekto at mga designers ay dapat umasa sa prinsipyo ng pinakamaliit na pribilehiyong magdesisyon kapag ang mga ito ay nararapat na gamitin at drop sa sistema ng mga pribilehiyo.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Authorization</reference>
	<reference>http://cwe.mitre.org/data/definitions/284.html</reference>
	<reference>http://cwe.mitre.org/data/definitions/285.html</reference>
</vuln_item_wasc_2>

<vuln_items>wasc_3</vuln_items>
<vuln_item_wasc_3>
	<alert>Nag-uumapaw ang integer</alert>
	<desc>Ang integer Overflow ay kondisyon na nangyayari kapag ang resulta ng isang pang-aritmetic operasyon, tulad ng pagpaparami o karagdagan, ay lampas na sa pinakamalaking sukat ng integer type na ginagamit para maitago ito. Kapag ang integer overflow ay nagaganap, lilitaw ang mga naisalin na halaga "wrapped around" ang pinakamataas ng halaga ay nagsimula muli sa pinakamababang halaga, katulad ng isang orasan na kumakatawan sa 13:00 sa pamamagitan ng pagturo sa 1:00.

Halimbawa, isang 8-bit nilagdaan na integer sa pinaka-karaniwang na arkitektura ng computer ay may isang pinakamataas na halaga ng 127 at isang pinakamababa na halaga na -128. Kung ang programmer ay nag-stores ng halaga na 127 sa naturang isang variable at nagdadagdag ng 1 na ito, ang resulta ay dapat 128. Gayunman, ang halaga ay lumampas ang pinakamataas para sa ganitong uri ng integer, kaya ang naisalin na halaga ay "wrap around" at maging ang -128.</desc>
	<solution>Yugto: Mga requirements
Pagsiguro na ang lahat ng mga protocols ay istriktong itinutukoy, Gayon man ang lahat ng mga out-of-bounds behavior ay kiniala ang simple, at kinakailangan ang istriktong conformance sa protocol.

Yugto: Mga Requirements
Paggamit ng wika na hindi nag pahintulot sa gamitong mga kahinaan o nagbibigay ng constructs na gumagawa ng kahinaan na madaling itong maiwasan.
Kung posibleng, makapili ng wika o compiler na gumagawa ng automatic bounds checking.

Yugto: Arkitekture at Disenyo
Gamitin ang vetted library o framework na hindi nag papahintulot ng kaninaan para mangyari o nagbibigay constructs na gumagawa ng kahinaan na madaling maiwasan.
Gamitin ng mga aklatan o mga balangkas na pinapadaling mahawakan ang mga numero nang walang hindi akalaing mga kahihinatnan.
Mga Halimbawa ang mga ligtas na pagbuo sa pagkapit ng pagbubuo tulad ng SafeInt (C++) o IntegerLib (C or C++.

Salita: Pagsasagawa
Magsagawa ng pagpapatunay ng pag-input sa anumang numerong input sa pamamagitan ng pagtutukoy sa nasa loob ng inaasahan na saklaw. Pilitin na matugunan ng input ang parehong pinakamababa at pinakamataas na kinakailangan para sa inaasahang saklaw.
Gamitin ang hindi na pirmahang pambuo kung saan posible. Ito ay ginagawang mas madali ang pagsasagawa ng mga pag-susuri ng katinuan para sa overflow ng pagbubuo. Ito ay kung dapat mong gumamit ng mga na pirmahang pagbubuo, siguraduhin na ang iyong hanay ng pagsusuri ay may kasamang mga pinakamababa na halaga pati na rin ang pinakamataas na halaga.

Panimula: pagsasagawa
Intindihin ang pinagbabatayang representasyon ng lengguwahe ng iyong palatuntunan at kung paano ito maiuugnay sa pagkalkula ng numerong (CWE-681). Mag-bigay alintana sa pagkakaiba ng byte, katumpakan, naka-pirma / hindi-pirma mga pagkakakilanlan, pag-putol, pag-salin at paghahagis sa pagitan ng mga anyo, mga "hindi-isang-bilang" na kalkulasyon, at kung paano ang iyong lengguwahe ay humahawak ng mga numero na masyadong malaki o masyadong maliit para sa pinagbabatayang paglalarawan nito.
Kailangan mag-ingat sa account para sa 32-bit, 64-bit, at iba pang maaaring pagkakaiba na pweding makaapekto sa Nauukol sa bilang na representasyon.

Panimula: pagsasagawa
Ang pag-susuri ng mga tagatipon ng babala at alisin ang maaring mga problema na pangkaligtasan sa katiwasayan, tulad ng naka-pirma / hindi naka-pirma ay hindi magkatulad. Maski na ang kahinaan ay bihira na nagagamit, ang isang kabiguan ay maaaring mapunta sa pangako ng buong sistema.</solution>
	<reference>http://projects.webappsec.org/Integer-Overflows</reference>
	<reference>http://cwe.mitre.org/data/definitions/190.html</reference>
</vuln_item_wasc_3>

<vuln_items>wasc_4</vuln_items>
<vuln_item_wasc_4>
	<alert>Kulang ang pag-lipat ng patong na proteksyon</alert>
	<desc>Kulang ang pag-lipat ng patong na proteksyon
Kulang ang pag-lipat ng patong na proteksyon pinahihintulutan ang komunikasyon na mahayag sa hindi pinagkakatiwalaan na mga third party, na nagbibigay ng isang attack vector upang mangako ang isang web aplikasyon at / o kumuha ng sensitibong kaalaman. Ang karamihan ng website ay gumagamit ng Secure Sockets Layer / Transport Layer Security (SSL / TLS) upang maghanda ng encryption sa transport layer. Gaano man, maliban kung wala ang website ay naka-configure na gagamitin SSL/TLS at naka-configure upang gamitin SSL/TLS maayos, pweding mahina ang website sa pagharang ng trapiko at pagbabago.
 
Sa kawalan ng transport patong encryption nang transport ay hindi encrypted patong, ng lahat ng komunikasyon sa pagitan ng mga website na kliyente ay nagsugo na linisin ang teksto na ang mga dahon pagbuksan pati, injection at redirection (kilala rin bilang man-in-the-middle/MITM attack). Ang isang pag-salakay ay maaaring pumipigil sa komunikasyon, na nagbibigay sa kanila ng daan sa anumang sensitibong datos na ipadala gaya ng mga ginagamit na pagngalan at password. Ang isang pag-salakay ay pwede ring aktibong mag-iniksyon/mag-tanggal ng nilalaman mula sa komunikasyon, na nagpapahintulot sa pag-atake ng pag-salakay at pag-omit ng kaalaman, mag-impok ng malisyosong pag-script, o maging sanhi ng kliyente na ma-kadaan ang remote sa hindi pinagkakatiwalaang nilalaman. Ang isang pagsalakay ay pwedi ring dumirekta ang komunikasyon sa isang paraan na ang website at kliyente ay hindi na makapagsabi sa isa't isa, ngunit sa halip ay hindi makilala ang pakikipag-usap sa pagsalakay sa konteksto ng iba pang pinagkakatiwalaang pangkat.

Ang Cipher Support ay Mahina
Sa pangkasaysayan, ang mataas na ranggo ng cryptography ay pinag-takda mula sa pag-luwas sa labas ng Estados Unidos. Dahil dito ang, websites ay kailangan naka configure upang masupportahan ang mahinang cryptographic na pagpipilian para s mga kliyente na pinag-takda lamang sa paggamit ng mga mahinang ciphers. Ang mahina na ciphers ay hindi-ligtas laban sa pag-atake dahil sa kamag-anak na kadalian ng pagwasak sa kanila; mas mababa sa dalawang linggo sa isang pangkaraniwan na kompyuter sa bahay at ilang segundo gamit ang dedikadong hardware.
Ngayon, ang lahat ng mga modernong browser at mga website ay ginagamit ng mas malakas na encryption, subalit ang ilang mga website ay naka-configure pa rin upang masuportahan ang mga laos na mahinang ciphers. Dahil dito, ang isang pagsalakay ay pweding mapilit ang client na i-baba sa isang mahinang cipher kapag kumukonekta sa website, na nagpapahintulot sa pagsalakay na sirain ang mahinang pag-encrypt. Dahil sa kadahilanang ito, dapat i-configure ang server upang tanggapin lamang ang mga malalakas na ciphers at hindi magbibigay ng paglilingkod sa anumang kliyente na humiling ng paggamit ng mahinang cipher. Sa karagdagan, ang ilang mga website ay may maling pag-kaayos upang pumili ng isang mahina na cipher kahit na ang kliyente ay sinusuportahan sa isang mas malakas na isa. Nag-aalok ang OWASP ng gabay sa pagsusuri para sa mga problema ng SSL / TLS, kabilang ang mahinang suporta sa cipher at misconfiguration, at may iba pang mga mapagkukunan at kasangkapan pati na rin.</desc>
	<solution>Malinis na tukuyin kung aling mga datos o mga mapagkukunan ay sapat na mahalaga na dapat silang protteksyunan sa pag-encrypt. Hiling√≠n na ang anumang paghahatid o pag-imbak ng datos / mapagkukunan na ito ay dapat gumamit ng gumagana na vetted na mga algorithm ng pag-encrypt.

Yugto: Arkitektura at Plano
Gamit ang pagmomolde ng pagbabanta o iba pang mga pamamaraan, ipalagay na ang iyong dattos ay maaaring makompromiso sa pamamagitan ng isang hiwalay na kahinaan o kahinaan, at matukoy kung saan ang encryption ay pweding pinaka-epektibo. Siguraduhin na ang datos na pinaniniwalaan mong dapat na pribado ay hindi sinasadyang ma-expose gamit ang mga kahinaan tulad ng hindi secure na mga permiso (CWE-732).

Yugto: Arkitektura at desenyo
siguraduhin na ang encrytion ay naintegrated sa system ng design kasama narin pero hindi kailangang limitahan.
ang encryption ay kailangang maitago o mailagay sa pribadong datos ng mga gumagamit o may nag mamay ari ng system
Ang encryption ay kailangang protektahan ang system mismo  sa mga hindi awtorisadong pagsisiwalat o pakikialam.
alamin ang mga kailangang at separadong konteksto ng encryption. Ito ay makakamit sa pamamagitan ng pampublikong susi o pamamaraan ng crytography, o ibang teknik kung san ang encryting party (i.e.,ang software)ay hindi kailangang magkaroon ng access para sa pribadong key o pamamaraan.
      Dalawang daan(i.e.,ang encryption ay pwedeng mag awtomatik sa pag galaw o pag perform sa ngalan ng may nagmamay ari, pero ang key ay kailangang maging available o kailangan magamit nang sa ganoo ang plaintext ay awtomatikong ma rerecover o maaaring marecover ng nag mamay ari). Ito ay nangangailangan ng mapag iimbakan ng mga pribadong key sa format na maaaring marecover pa ng mismong nag mamay ari (o kaya ng operating system o sa nag ooperate ng system) sa paraan na hindi marerecover ng iba.

Yugto: Arkitektura at Desenyo
Huwag mag develop o gumawa ng sariling crytographic algorithms. Maaring may mga naka exposed o nakalantad para umatake para sa mga nakakaalam ng cryptograps. Ang mga teknik ng reverse engineering ay pang bihasa. Kung ang algorithm ay makompormiso ng mga sumasalakay at malaman kung papaano ito gumagana, ang ibig sabihin nito na algorithm ay mahina.

Yugto: Arkitektura at Desenyo 
Piliin ang ang magaling o magandang vetted algorithm na kasalukuyang itunuturing na malakas ng mga eksperto sa larangan ng arkitektura, at piliin ang magaling o magandang vetted na pinatutupad.
Halimbawa, ang Sistema ng Gobyerno ng Estados Unidos ay kailangan ng FIPS 140-2 na katunayan o katibayan.
Katulad ng lahat ng mga mapaparaan ng kriptograpiko, ang source code ay kailangan magagamit sa pag aanalize.
Laging tiyakin na hindi ka gumagamit ng lipas o wala ng bisang kriptograpi. Ang ibang matanda o lumang algorithms, minsang napag isipan kailanganan ng bilyong taon para sa suma ng oras, ngayon ay kayang buwagin o sirain ng isang araw o ilang oras lamang. Kasama nito ang MD4, MD5, SHA1 DES, at ang ibang algorithms kung saan ang mga ito ay pinagpipitagan bilang malakas.

Yugto: Arkitektura at Desenyo
pag samasamahinang iyongmga sistema ng sagoon ay magkaroon ka ng seguridad. sa lugar na kung saan ay nagtitiwala kang hindi ito magagalaw o makukuha ng iba. Huwag payagan ang mga sensitibong datos na mag punta sa labas ng pinagkaktiwalaang lugar o lalagyanan at kaialngang lagi ay maging maingat lalo na sa pag interface sa mga kasama sa labas ng ligtas na lalagyan o lugar.

Yugto: Implementasyon; Arkitektura at Desenyo
Kapag ikaw gumagamit ng pang industriyang na aprobahan ng mga teknik, ikaw ay kailangan na gamitin ng tama. Huwag gupitin o hatiin ang sulok sa pamamagitan ng paglaktaw ng mapagkukunan ng matinding hakbang.(cwe-325). Narito ang mga hakbang na palaging ginagamit o karanawang ginagamit para maiwasan ang mga sumasalakay.

Yugto: Implementasyon
Gumamit ng pangalan na gianmitan ng mga pang konbesyon at malakas na uri upang makagawa ng mas madaling spot kapag sensitibo ang datos na ginagamit. Kapag lumilikha ng mga istruktura, mga bagay, o iba pang mga kumplikadong mga entity, ihiwalay ang sensitibo at hindi-sensitibong datos hangang sa maaari.
Ginagawa nitong mas madali na makita ang mga lugar sa code kung saan ang datos ay ginamit na unencrypted.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Transport-Layer-Protection</reference>
	<reference>http://cwe.mitre.org/data/definitions/311.html</reference>
</vuln_item_wasc_4>

<vuln_items>wasc_5</vuln_items>
<vuln_item_wasc_5>
	<alert>Pagbuo ng remote na file</alert>
	<desc>Pag buo ng file. Kapag ang aplikante ng webay kumuha ng user input (URL, halaga ng parametro, atb.) at naipasa nila sa file kasama ang mga utos, ang aplikante ng web ay maaring ma trick kasama ang remote na files na may kasamang malisyosong code.

Halos lahat ng aplikante ng web ay framework ay kasama ng suportang file. Ang pag sasama ng file ay isa sa pinkaginagamit para sa pag papack ng karaniwang code para sa separadong files na kadalasang ay nagiging sanggunnihan ng pangkalahatang aplikante ng modyul. Kapag ang web na aplikasyon ay nagmungkahi na isama ang file, ang code para dito ay maaring ibigay sa pamamaraang pagtawag o pagbibigay ng partikular na pamamaraan. Kapag ang napili mong modyul ay para mag lagay ng batayan ng mga elemento galing sa HTTP na hiling. ang web na aplikasyon ay maaring mahina sa RFI.
Ang umaatake ay may kakayahang gumamit ng RFI para sa. Kapag ang file ay hindi na execute o naisagawa gamit ang ilang wrapper, ang code sa kasamang file ay maisasagawa sa konteksto ng gumagamit ng servver. Ito ay maaring mag bigay daan para sa kumpletong sistema ng kompormiso.
    *Ang pagtakbo o pag gamit ng malisyosong code sa kliyente. ang mga umaatake ay may malisyosong code na pwedeng imanipulate ang nilalaman ng mga kapalit na pag bigay sa kliyente. Ang umaatake ay kayang kumuha ng mga malisyosong code na pabalik na pwedeng magpatakbo ng mga kliyente (halimbawa, javascript para makuha ang session cookies ng kliyente.

PHP ay partikular na mahina para sa RFI na umaatake sa mga di kasamang pag gamit ng "file includes" sa PHP na programa at dahil sa default server ang pag gamit ng configuration ay tumataas ng pagkakamaramdamin ng RFI attack.</desc>
	<solution>Yugto: Arkitektura at Plano
Kung nakatakda o kilala ang hanay ng mga katanggap-tanggap na bagay, tulad ng mga pangalan ng file o URL, gumawa ng isang pagmamap mula sa isang hanay ng mga nakapirming halaga ng input (tulad ng mga numerong ID) sa aktwal na mga pangalan ng filename o URL, at tanggihan ang lahat ng iba pang mga input.
Para sa halimbawa, ID 1 pweding e map sa "inbox.txt" at ID 2 pweding e map sa "profile.txt". Ang mga tampok kapareho ng ESAPI AccessReferenceMap ay naglalaan ng kakayahan na ito.

Mga yugto: Arkitektura at plano; Operasyon
Paganahin ang iyong code sa isang "bilangguan" o kapareho na sandbox ng kapaligiran na nagpapatupad ng mahirap na mga hangganan sa pagitan ng pag-proseso ng operating system. Ito ay maaring epektibong restrict kung saan ang files ay pwedeng magamit sa partikular na directory o kung saan ang utos ay maaring magamit o maisagawa ng iyong software.
Ang OS-level ay mga ehemplo na kasama ang Unix chroot jail. AppArmor, at SELinux. Sa pangakalahatan, ang pag mamanage ng code ay pwedeng magbigay ng ilang proteksyon. Halimbawa, java.io FilePermission sa mga Java SecurityManager na mag aallow sayo ng pagtukoy sa mga restrictions o sa mga mahigpit na file na operasyon.
Ito ay maaring di magawan ng solusyon, at ito ay limitasyon sa pag impact ng mga sitemang nag ooperate; at ang lahat ng iyong aplikasyon ay maaring maging paksa para sa kompormiso.
Mag-ingat at iwasan ang CWE-243 at ang ibang mahihina na may kaugnayan sa bilangguan.
Para sa PHP ang interpreter o tagasalin ng wika ay nag ooffer ng restrictions sa mga bukas na basedir o ligtas nga mode kung saan pwedeng gawing mas mahirap para sa umaatake na makaiwas sa labas ng aplikasyon. Isaalang alang din ang Suhosin, a pinagtibay ng PHP extension, kung saan ito ay kasama sa ibat ibang opsyonal na maaring mag disable o hindi mapagawa ang marami pang mas mapanganib na PHP na maga tampok.

Yugto: pagpapatupad
Ipagpalagay na ang lahat ng input ay malisyoso. Gamitin ang "accept known good"mahusay na pagtanngap at pagkilala o ang pag validate ng input na stratehiya,i.e., gamitin ang puting listahan o whitelist para sa pagtanggap ng ng mga input na striktong sumusunod sa pagtukoy. Tanggihan ang mga input na hindi strikto sa pag conform sa pagtutukoy o sa pag transform nito sa ibang bagay na ginagawa nito. Huwag mag rely sa eksklusibon na pagtingin sa malisyosong o di maayos na input(i.e.,huwag mag rely sa itim na listahan o sa blacklist). Gayon pa man, ang itim na listahan o ang blacklist ay maaaring magamit para sa pagdetect ng potensyal na atake o sa pagtukoy ng mga inputs ay hindi maayos na maaring tanggihan agad.
Kapag ginagamit ang input na validation, iconsider na ang lahat ng potensyal na may kaugnayan sa mga properties, kasama na rito ang haba, tipo ng input, ang buong kakayahan ng pagtanggap ng halaga, kawalan o iba pang inputs, syntax, pagkakapareho sa mga parehong larangan at pagsang-ayon sa mga panuntunan sa negosyo. Bilang isang halimbawa ng lohika sa patakaran sa negosyo, ang "bangka" ay pweding tama syntactically dahil naglalaman lamang ito ng mga alphanumeric na pag-uugali, ngunit hindi ito tama kung umaasa ka ng mga kulay na kapareho ng "red" o "blue."
Para sa mga filename, gamitin ang mga mahigpit na whitelist na lumilimita sa hilera ng character na gagamitin. Kung magagawa, pahintulutan lamang ang isang solong "." karakter sa filename upang maiwasan ang mga kahinaan kagaya ng CWE-23, 
at ihiwalay ang mga separator ng direktoryo kagaya ng "/" upang maiwasan CWE-36. Gumamit ng whitelist na nagpapahintulot sa lawig ng file, na maaring makakatulong upang maiwasan ang CWE-434.

Mga yugto: Arkitektura at plano; Operasyon
Magtabi ng aklatan, isama, at mga utility file sa labas ng web document root, kung pepwedi. O kaya, i-store sila sa isang nakahiwalay na direktoryo at gamitin ang mga kakayahan ng access kontrol ng web server para mapigilan ang mga aatake mula sa direktang pag-hiling sa kanila. Isang karaniwang pagsasanay ay ang pagtukoy sa isang fixed na constant sa bawat calling program, pagkatapos ay ang pag-check sa pagkakaroon ng constant sa library/include file; kung ang constant aay hindi umiiral, kung gayon ang file ay direktang iniling, at ito ay maaaring i-exit kaagad.
Ito ay makabuluhang magpapababa ng tsansa ng isang aatake na magawang lagpasan ang anumang mga mekanismong proteksyon na nasa base program ngunit hindi nasa include files. Mababawasan din nito ang iyong attack surface.

Yugto: Arkitektura at Plano; Pagpapatupad
Maunawaan ang lahat ng mga potensyal na lugar kung saan pweding ipasok ng mga hindi pinagkakatiwalaang input ang iyong software: mga parameter o argumento, cookies, sa anumang nabasa mula sa network, mga baryante ng kapaligiran, saliwang pag-tingin sa taas ng DNS, mga resulta ng tanong, sa ulo ng kahilingan, mga bahagi ng URL, e-mail, mga file, database, at anumang mga panlabas na sistema na nagbibigay ng datos sa pagpapairal. Tandaan na ang mga ganong input ay maaaring hindi direktang makuha sa pamamagitan ng mga API call.
Many file inclusion problems occur because the programmer assumed that certain inputs could not be modified, especially for cookies and URL components.</solution>
	<reference>http://projects.webappsec.org/Remote-File-Inclusion</reference>
	<reference>http://cwe.mitre.org/data/definitions/98.html</reference>
</vuln_item_wasc_5>

<vuln_items>wasc_6</vuln_items>
<vuln_item_wasc_6>
	<alert>String ng Format</alert>
	<desc>Ang pagbago ng pag-atake ng String ng ayos ang daloy ng isang pag-papairal sa pamamagitan ng paggamit ng mga tampok sa pag-ayos ng format ng library upang ma-kadaan ang iba pang espasyo ng memorya. Ang mga kahinaan ay nangyayari kapag ang datos na naibigay ng taga-gamit ay direktang ginagamit bilang pag-format ng input ng string para sa ilang C/C++ functions (e.g. fprintf, printf, sprintf, setproctitle, syslog, ...).

Kung ang isang sasalakay ay makapasa sa isang format na string na binubuo ng mga character ng printf na pinag-usapan (e.g. "%f", "%p", "%n", etc.) bilang isang parameter na halaga sa web aplikasyon, pwedi silang:
    * Ipatupad ang arbitrary code ng server
    * Basahin ng mga halaga mula sa stack
    * Ang sanhi ng mga pagkakamali ng segmentation / pag-kasira ng software

Ang pag-atake ng string ay may kaugnayan sa iba pang mga pag-atake sa banta ng pag-uuri: Buffer pag-apaw sa pag-apaw ng Integer. Ang lahat ng tatlo ay batay sa kanilang kakayahan na mamahala ang memorya o interpretasyon nito sa isang paraan na nag-aambag sa layunin ng magsasalakay.</desc>
	<solution>Ang yugto: pangangailangan
Pumili ng isang lengguwahe na hindi napapailalim sa lamat na ito.

Ang yugto: Pagpapatupad
Siguraduhin na ang lahat ng mga tungkuli ng format ng string ay pinapasa sa isang estatika na string na hindi pweding kontrolin ng gumagamit at ang tamang bilang ng mga argumento ay palaging ipinapadala sa tungkulin na rin. Kung posible, gumamit ng mga function na hindi sumusuporta sa %n operator sa mga format string.
Build: Heed the warnings of compilers and linkers, since they may alert you to improper usage.
</solution>
	<reference>http://projects.webappsec.org/Format-String</reference>
	<reference>http://cwe.mitre.org/data/definitions/134.html</reference>
</vuln_item_wasc_6>

<vuln_items>wasc_7</vuln_items>
<vuln_item_wasc_7>
	<alert>Ang umaapaw na buffer</alert>
	<desc>Ang Buffer Overflow ay isang lamat na nangyayari kapag mas maraming datos ang nakasulat sa isang bloke ng memorya, o buffer, kaysa sa buffer ay inilaan upang hawakan. Ang pagargabyado sa overflow ng buffer ay nagbibigay-daan sa isang magsasalakay na baguhin ang mga bahagi ng patlang na kinaroroonan ng target na pag-proseso. Ang kakayahan na ito ay pweding magamit para sa maraming layunin, kabilang ang mga sumusunod:
    * ang pag-kontrol sa pagpapatupad ng proseso
    * Sirain ang pag-proseso
    * Baguhin ang panloob na mga baryante

Ang layunin ng magsasalakay ay halos palaging makontrol ang pagpapatupad ng target na pag-proseso. Ito ay maisasagawa sa pamamagitan ng pagtukoy sa isang function pointer sa memorya na maaaring mabago, direkta o hindi direkta, gamit ang overflow. Kapag ang naturang pointer ay nagagamit ng programa upang maidirekta ang pagsasagawa ng programa sa pamamagitan ng pagtalon o pagtawag sa pagtuturo, gainagamit ang lokasyon ng pagtuturo na ibinigay ng pagsalakay, sa gayon ay pinahihintulutan ang magsasalakay na kontrolin ang proseso.

Sa maraming mga kaso, ang tungkulin ng pointer ay binabago upang i-sanguni ang isang lokasyon kung saan ang magsasalakay ay nakalagay na nagsama ng mga tagubilin sa makina na natukoy. Ang mga instruksyon na ito ay karaniwang tinatawag bilang shellcode, batay sa katotohanan na ang mga aatake ay kalimitang humihiling na i-spawn ang command-line na environment, o shell, sa konteksto ng tumatakbong proseso.

Buffer overflows are most often associated with software written in the C and C++ programming languages due to their widespread use and ability to perform direct memory manipulation with common programming constructs. It should be emphasized, however, that buffer overflows can exist in any programming environment where direct memory manipulation is allowed, whether through flaws in the compiler, runtime libraries, or features of the language itself.
</desc>
	<solution>Yugto: Mga Requirements
Paggamit ng wika na hindi nag pahintulot sa gamitong mga kahinaan o nagbibigay ng constructs na gumagawa ng kahinaan na madaling itong maiwasan.
Halimbawa, maraming mga lengguwahe na nagsasagawa ng kanilang sariling pamamahala sa memorya, tulad ng Java at Perl, ay hindi napapasailalim sa overflows ng buffer. Ibang mga lengguwahe, tulad ng Ada at c#, karaniwang nagbibigay ng proteksyon sa overflow, ngunit ang proteksyon ay maaaring hindi paganahin ng programmer.
Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.

Yugto: Arkitekture at Disenyo
Gamitin ang vetted library o framework na hindi nag papahintulot ng kaninaan para mangyari o nagbibigay constructs na gumagawa ng kahinaan na madaling maiwasan.
Examples include the Safe C String Library (SafeStr) by Messier and Viega, and the Strsafe.h library from Microsoft. These libraries provide safer versions of overflow-prone string-handling functions. This is not a complete solution, since many buffer overflows are not related to strings.

Ang yugto: Ang pag-tatag at pag-samasama
Patakbuhin o tipunin ang iyong software gamit ang mga tampok o lawig na awtomatikong nagbibigay ng mekanismo ng proteksyon na nagpapagaan o nag-aalis ng overflow ng buffer.
Ang halimbawa, ang ilang mga taga-tipun at mga lawig ay nagbibigay ng awtomatikong mekanismo ng pag-tuklas ng overflow ng buffer na itinatag sa naimbak na code. Ang kalakip sa mga halimbawa ang flag ng Microsoft Visual Studio /GS, Fedora/Red Hat FORATIFY SOURCE GCC flag, StackGuard, at ProPolice.

Ang Yugto: Pagpapatupad
gunitain ang pagsunod sa mga sumusunod na alituntunin kapag naglalaan at namamahala ng memorya ng isang aplikasyon:
     doublehin ang pag-suri kung ang buffer mo ay kasing dami ng iyong tinukoy.
      Kapag gumagamit ng mga function na tumatanggap ng isang bilang ng bytes para kopyahin, tulad ng strncpy(), magkaroon ng kamalayan na kung ang sukat ng destination buffer ay katumbas ng sukat ng source buffer, ito ay maaaring hindi mag NULL-terminate ng string.
      Check buffer boundaries if calling this function in a loop and make sure you are not in danger of writing past the allocated space.
      If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.

Ang Yugto: Operasyon
Ang pag-gamit ng isang tampok tulad ng Address Space Layout Randomization (ASLR).

Ang Yugto: Operasyon

Ang pag-gamit ng CPU at operating system na nag-aalok ng Data Execution Protection (NX) o kahambing nito.

Ang Yugto: Pagpapatupad

Ang pag-papalit ng mga limitasyon ng mga tungkulin ng kopya na may mga analog na tungkulin na suportado ng mga argumento ng haba, kagaya ng strcpy na may strncpy. Gawin ito kung, ito ay hindi pwedi.
</solution>
	<reference>http://projects.webappsec.org/Buffer-Overflow</reference>
	<reference>http://cwe.mitre.org/data/definitions/119.html</reference>
</vuln_item_wasc_7>

<vuln_items>wasc_8</vuln_items>
<vuln_item_wasc_8>
	<alert>Ang cross-site na scripting</alert>
	<desc>Ang Cross-site na scripting (XSS) ay isang atake na technique na bumabalot ng echoing ng attacker-supplied na code sa loob ng isang user browser na instance. Ang isang browser instance ay pwedeng isang standard web browser na client, o isang browser object embedded sa isang software produkto tulad ng browser sa loob ng WinAmp, isang RSS na reader, o isang email client. The code itself is usually written in HTML/JavaScript, but may also extend to VBScript, ActiveX, Java, Flash, or any other browser-supported technology.
When an attacker gets a user's browser to execute his/her code, the code will run within the security context (or zone) of the hosting web site. With this level of privilege, the code has the ability to read, modify and transmit any sensitive data accessible by the browser. A Cross-site Scripted user could have his/her account hijacked (cookie theft), their browser redirected to another location, or possibly shown fraudulent content delivered by the web site they are visiting. Cross-site Scripting attacks essentially compromise the trust relationship between a user and the web site. Applications utilizing browser object instances which load content from the file system may execute code under the local machine zone allowing for system compromise.

There are three types of Cross-site Scripting attacks: non-persistent, persistent and DOM-based.
Non-persistent attacks and DOM-based attacks require a user to either visit a specially crafted link laced with malicious code, or visit a malicious web page containing a web form, which when posted to the vulnerable site, will mount the attack. Ang paggamit ng isang malisyosong form ay kalimitang nagaganap kapag ang tinatanggap lamang ng vulnerable resource ang HTTP POST na mga kahilingan. In such a case, the form can be submitted automatically, without the victim's knowledge (e.g. by using JavaScript). Upon clicking on the malicious link or submitting the malicious form, the XSS payload will get echoed back and will get interpreted by the user's browser and execute. Another technique to send almost arbitrary requests (GET and POST) is by using an embedded client, such as Adobe Flash.
Persistent attacks occur when the malicious code is submitted to a web site where it's stored for a period of time. Examples of an attacker's favorite targets often include message board posts, web mail messages, and web chat software. The unsuspecting user is not required to interact with any additional site/link (e.g. an attacker site or a malicious link sent via email), just simply view the web page containing the code.</desc>
	<solution>Yugto: Arkitekture at Disenyo
Gamitin ang vetted library o framework na hindi nag papahintulot ng kaninaan para mangyari o nagbibigay constructs na gumagawa ng kahinaan na madaling maiwasan.
Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.

Yugto: Implementasyon; Arkitektura at Desenyo
Intindihin ang konteksto kung saan ang iyong datos ay pwedeng gamitin at ang pag encode ay expected. Ito ay espesyal at importante kapag nag tatransmit o nag papasa ng datos sa pagitan ng mag kaibang components o mga sangkap. o kapag nag gegenerate ng mga output na maaaring may laman na maraming mga encoding sa parehong oras, tulad ng mga pahina sa web o sa maraming parte ng sulat at mensahe. Pag aralan ang lahat na inaasahang komyunikasyon protokol at datos ng representation na makilala o matukoy ang kinikailangang pag eencode at mga estratehiya.
Kahit na sa anong datos ay magiging output sa ibang pahina ng web, lalo na ang ibang datos na matatanggap sa labas ng mga input, gamitin ang tamang pag eencode sa lahat ng non-alphanuemeric na karakter.
Kumunsulta sa XSS para sa pag iwas ng madayang pilas ng papel o Prevention Cheat Sheet para sa mas maraming detalye sa mga uri ng pag eencoode at sa pagtakas na kinakailangan.

Yugto: Arkitektura at Disenyo 
Para sa ibang seguradid na pag suri na ang pag perform sa kliyente, siguraduhin na ang pag susuri ay dalawa para naman sa server, upang maiwasan ang CWE-602. Ang mga umaatake ay maaring bypass sa side ng kliyente suriin ang modipikasyon ng halaga bago pa matapos ang pagsusuri ay magawa, o sa pagbabago ng kliyente sa pagtanggal ng kabuoang pag susuri sa kliyente. Pagkatapos, ang modipikasyon ng halaga ay maaaring ipasa sa server.

Kung may magagamit o may mapapakinabangan, gamitin ang structued na mekanismo na awtomatikong mag eenforce ng separado sa pagitan ng datos at code. Ang Mekanismong ito ay maaring mag provide o maghanda ng may kaugnayan sa quoting, pag eencode at sa awtomatikong balidasyon, sa halip na umasa ang mga nag develope ang gumawa ng kapasidad o kakayahan sa lahat ng pagkakataon kapag ang output ay nagenerate.

Yugto: Implementasyon
Para sa lahat ng pahina ng web na nag gegnerate, gamitin ang specify na karakter sa pag eencode tulad ng ISO-8859-1 or UTF-8. Kapag ang pag eencode ay hindi specified o hindi kilala, ang web na browser ay pipili ng ibang encoding gamit ang pag hahanap ng ibang encoding na nagamit na ng pahina ng web. Ito ay maaaring magdulot sa web browser ng trato sa tiyak na sequences bilang espesyal na pag bubukas ng kliyente sa banayad na XSS na mga atake. Tignan ang CWE-116 para sa mas maraming mitigasyon na may kaugnayan sa pag eencode/at pagtakas.

Para matulungan ang mitigasyon sa mga umaatake sa XSS laban sa gumagamit ng session cookie, ihanda ang session cookie sa HttpOnly. Ang pag suporta HttpOnly ng browser ay tampok (tulad ng mas maraming kamakailang bersyon ng internet explorer ang Firefox), ang attribute na ito ay maaaring pigilan ng mga gumagamit ng session na cookie galing sa maaring puntahan na malisyosong eskripto ng kliyente na gumagamit ng dokomento ng cookie. Ito ay hindi kumpletong solusyon, since ang HttpOnly ay hindi sinuportahan ng lahat ng browser. Ang mas mahalaga, XMLHTTPRequest at ang ibang mas malakas na teknolohiya ng browsers na nagbibigay ng pag basa at pag tukoy sa HTTp headers, kasama na rito ang sert ng cookie header kung saan ang HttpOnly flag ay na set.

Ipagpalagay ang lahat ng input ay malisyoso. Gamitin ang "accept known good"mahusay na pagtanngap at pagkilala o ang pag validate ng input na stratehiya,i.e., gamitin ang puting listahan o whitelist para sa pagtanggap ng ng mga input na striktong sumusunod sa pagtukoy. Tanggihan ang mga input na hindi strikto sa pag conform sa pagtutukoy o sa pag transform nito sa ibang bagay na ginagawa nito. Huwag mag rely sa eksklusibon na pagtingin sa malisyosong o di maayos na input(i.e.,huwag mag rely sa itim na listahan o sa blacklist). Gayon pa man, ang itim na listahan o ang blacklist ay maaaring magamit para sa pagdetect ng potensyal na atake o sa pagtukoy ng mga inputs ay hindi maayos na maaring tanggihan agad.

Kapag ginagamit ang input na validation, iconsider na ang lahat ng potensyal na may kaugnayan sa mga properties, kasama na rito ang haba, tipo ng input, ang buong kakayahan ng pagtanggap ng halaga, kawalan o iba pang inputs, syntax, pagkakapareho sa mga parehong larangan at pagsang-ayon sa mga panuntunan sa negosyo. Bilang ehemplo ng negosyo sa panuntunan ng lohika, " bangka" ay may systacticaally na balido sapagkat ito lamang ang naglalaman ng alphanumeric na karakter, pero ito ay hindi balido kung ang iyong inaasahang kulay at "pula at asul."

Pakariguraduhin na ang pag perform ng input ay balido sa sa well mga interface sa mga aplikasyon. Ito ay makakatulong sa aplikasyon kahit na ang mga component o mga nilalaman ay nagamit na o nailagay kung saan man.
	</solution>
	<reference>http://projects.webappsec.org/Cross-Site-Scripting</reference>
	<reference>http://cwe.mitre.org/data/definitions/79.html</reference>
</vuln_item_wasc_8>

<vuln_items>wasc_9</vuln_items>
<vuln_item_wasc_9>
	<alert>Kahilingan para sa Cross Site</alert>
	<desc>Ang kahilingan para sa cross site ay isang atake na kasangkot sa pagpwersa ng biktima na magpadala ng HTTP na hiling sa mga target na destinasyon na walang kaalaman o intensyon na mag perform ng ibang aksyon ng mga biktima. Ang cause na pinagbabatayan ng aplikasyon ng funcionality na ginamit sa pag predikta ng URL/uri ng aksyon na umuulit na paraan. Ang kalikasan ng pag atake ay ang CSRF na kapakinabangan ng tiwala ng web site para sa gumagamit. Sa kabilang banda, ang cross site scripting (XSS) ay may kapakinabangan na ang gumagamit ay para sa web site. Katulad ng XSS, CSRF ang mga atake ay hindi necessarily ng cross-site pero hindi maaari. Ang Cross site ay kahilingan ng 
forgery ay isa sa kilalang CSRF, XSRF, isang pindot ng pag atake. ang session riding, ang nalitong representante, at ang see surf.

CSRF na pag atake ay epektibo sa mga bilang na sitwasyon, kasama na rito ang 
*Ang biktima ay aktibong session sa mga target na site.
    *Ang biktima ay awtentikado via HTTP auth sa mga target na site.
    *Ang biktima ay na sa parehong lokal na network sa mga target na site.

CSRF ay pangunahing nagagamit para mag perform ng aksyon laban sa target na site gamit ang pribelihiyo ng biktima, pero ang kamakailang teknik ay natuklasana na isiwalat o ipaalam sa iba ang impormasyon sa pamamagitan ng pag kakaroon ng mga sagot. Ang panganib ng impormasyon na pag siwalat ay kapansin pansing pagtaas kapag ang target na site ay mahina sa XSS, dahil ang XSS ay ginagamit bilang platform ng CSRF, pinapayagang umatake at mag operate hanggang sa kanilang kakayahan sa parehong pinanggalingan ng palisiya.</desc>
	<solution>Yugto: Arkitekture at Disenyo
Gamitin ang vetted library o framework na hindi nag papahintulot ng kaninaan para mangyari o nagbibigay constructs na gumagawa ng kahinaan na madaling maiwasan.
Ang halibawa, gumamit ng anti-CSRF na pakete katulad ng OWASP CSRFGuard.

Yugto: Implementsyon
Pakasiguraduhin na ang aplikasyon ay di ginagamit o libre sa mga cross site scripting issues, dahil ang pinaka depensa ng CSRF ay pwedeng mabypassed gamit ang umaatake na kontrolado ng script.

Yugto: Arkitektura at Desenyo 
Bumuo ng kakaibang nonce para sa lahat ng porma, lugar at sa nonce sa mga porma, at maiverify o maalam ang nonce na resibo ng mga porma. Be sure that the nonce is not predictable (CWE-330).
Note that this can be bypassed using XSS.

Identify especially dangerous operations. When the user performs a dangerous operation, send a separate confirmation request to ensure that the user intended to perform that operation.
Note that this can be bypassed using XSS.

Use the ESAPI Session Management control.
This control includes a component for CSRF.

Do not use the GET method for any request that triggers a state change.

Ang Yugto: Pagpapatupad
Suriin ang header ng HTTP Referer upang makita kung ang kahilingan ay nagmula sa isang inaasahang pahina. This could break legitimate functionality, because users or proxies may have disabled sending the Referer for privacy reasons.</solution>
	<reference>http://projects.webappsec.org/Cross-Site-Request-Forgery</reference>
	<reference>http://cwe.mitre.org/data/definitions/352.html</reference>
</vuln_item_wasc_9>

<vuln_items>wasc_10</vuln_items>
<vuln_item_wasc_10>
	<alert>Ang pagtanggi ng serbisyo</alert>
	<desc>Ang pagtanggi ng serbisyo (DoS) ay isang pamamaraan sa pag-atake na ang layunin ay ang pagpigil sa web site mula sa paglilingkod ng normal na gumagamit sa kanyang gawain. Ang DoS na mga pag-atake, na kung saan ay madaling normal na inilipat na sa network na pagpatong, ay posible din sa pagpatong sa aplikasyon. Ang mga malisyosong mga pag-aatake na ito ay pwedeng magtagumpay sa pagbawas sa kritikal na mga pagkukunan, eksployt, o abuso sa kakayahan.

Maraming beses na ang mga pag-aatake ng DoS ay pagtatangka na ubusin ang lahat ng mapagkukunan ng magagamit ang website tulad ng: CPU, memory, disk space atbp. Nang sinuman sa mga kritikal na mapagkukunan ay lubos na nagamit, ang web site ay normal na hindi ma-access.

Sa ngayon ang web aplikasyon sa mga kapiligiran ay kinabibilangan ng isang web server, database server at isang pagpapatunay na server, DoS at ang aplikasyon na pagpatong ay maaring mag-target sa bawat isa na mga bahagi. Di tulad ng DoS sa patong na network, kung saan ang isang malaking bilang ng koneksyon na pagtatangka ay kinakailangan. Ang DoS sa patong na aplikasyon ay isang mas simpleng gawain na maisasagawa.</desc>
	<solution>Yugto: Arkitektura at Disenyo

Ang disenyo throttling na mga mekanismo sa sistema ng arkitektura. Ang pinakamainam na proteksyon ay limitahan ang halaga ng yaman na ang di-awtorisadong user ay maaring makadulot upang gastahin. Ang isang matibay na pagpapatunay at modelo ng access kontrol ay makakatulog na maiwasan ang gayong mga pag-atake mula sa nangyaring unang naganap. Ang login na aplikasyon ay dapat protektado laban sa pag-atake ng DoS hangga't maaari. Nilimitahan ang access sa database, marahil sa caching na nakalagay na resulta, makakatulong sa pagbawas ang pinagkukunan na ginasta. Para sa karagdagang limit ng potensyal para sa isang atake ng DoS, isaalang-alang ang taas ng halaga ng mga natatanggap na kahilingan mula sa mga gumagamit at bumabara ang mga hiling na lumagpas sa isang tinukoy na halaga ng limitasyon.

Paghumpay sa pagkaubos ng pinagkukunan ay aatake sa nangangailangan na ang sistema ng target alinman:
      kinikilala ang atake at tinanggihan ang gumagamit sa isinulong na pagpasok para sa isang ibinigay na oras, o
      magkakatulad ng mga throttles sa lahat ng mga kahilingan upang gumawa ng mas mahirap na pagkuha ng mapagkukunan ng mas mabilis kaysa sa kanilang nabawas muli. 

Ang una sa mga solusyon ay isang isyu sa sarili bagaman, dahil maari itong payagan ang mga nag-aatake na maiwasan ang paggamit ng sistema sa pamamagitan ng isang balidong gumagamit. Kung ang umatake ay kinokopya ang balidong gumagamit, pwede nitong pigilan ang gumagamit mula sa pagpasok sa server sa pagtatanong.

Ang pangalawang solusyon ay mahirap lamang sa epektibong istitute -- at kahit na isaktong matapos, ito ay hindi nagbibigay ng isang buong solusyon. Ito lang ay gumagawa sa atake na nangangailangan ng higit pang mapagkukunan ng parte sa umaatake.

Tiyakin na ang mga protocol ay partikular ang mga limit ng scale na inilagay sa kanila.

Yugto: Pagsasagawa
Tiyakin na ang lahat ng mga kabiguan sa alokasyong inilagay sa sistema sa isang ligtas na paglalagyan.</solution>
	<reference>http://projects.webappsec.org/Denial-of-Service</reference>
	<reference>http://cwe.mitre.org/data/definitions/400.html</reference>
</vuln_item_wasc_10>

<vuln_items>wasc_11a</vuln_items>
<vuln_item_wasc_11a>
	<alert>Ang brute na pamumuwersa sa Log-in Credentials</alert>
	<desc>Ang isang brute force na atake ay isang paraan para pagkuha ng isang hindi alam na halaga sa pamamagitan ng paggamit ng isang awtomasyon na proseso na sumubok ng isang malaking posibilidad na mga halaga. Ang pag-atake ay kumukuha ng kalamangan sa pangyayari na ang entropy sa mga halaga ay maliit sa inaasahan. Halimbawa, habang ang isang 8 karakter na alphanumeric pasword ay maaring magkaroon ng 2.8 trillion na posibleng mga halaga, maraming tao ay pipili sa kanilang mga password mula sa isang maliit na subset na bumubuo ng iisang salita at tuntunin.

Ang pina ka karaniwang uri ng isang brute force na atake sa web na mga aplikasyon ay isang atake laban sa log-in credentials. Pagkat ang mga gumagamit ay kailangang tandaan ang mga password, madalas silang pumili ng pinakamadaling matandaan na mga pananalita o salita bilang kanilang mga password, paggawa ng isang brute force na atake gamit ang isang diksiyonaryo ay magagamit. Gayong pag-atake ay sinusubok ang pag-login sa isang sistema gamit ang isang malaking listahan ng mga pananalita at salita bilang potensyal na mga password ay kadalasang tinatawag bilang "atake sa listahan ng pananalita" o isang "atake sa diksiyonaryo". Ang pagsusubok ng mga password maaring isinama ang kaibahan ng mga karaniwang salita sa mga password gaya ng nabuo sa pamamagitan ng pagpalit sa "o" ng "0" at "i" ng "1" gaya ng personal na impormasyon kasali ang mga pangalan ng mga miyembro ng pamilya, araw na isinilang at mga numero ng telepono.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11a>

<vuln_items>wasc_11b</vuln_items>
<vuln_item_wasc_11b>
	<alert>Ang Brute Forcing na sesyon na nagtutukoy</alert>
	<desc>Ang isang brute force na atake ay isang paraan para pagkuha ng isang hindi alam na halaga sa pamamagitan ng paggamit ng isang awtomasyon na proseso na sumubok ng isang malaking posibilidad na mga halaga. Ang pag-atake ay kumukuha ng kalamangan sa pangyayari na ang entropy sa mga halaga ay maliit sa inaasahan. Halimbawa, habang ang isang 8 karakter na alphanumeric pasword ay maaring magkaroon ng 2.8 trillion na posibleng mga halaga, maraming tao ay pipili sa kanilang mga password mula sa isang maliit na subset na bumubuo ng iisang salita at tuntunin.

Since HTTP is a stateless protocol, in order to maintain state web applications need to ensure that a session identifier is sent by the browser with each request. The session identifier is most commonly stored in an HTTP cookie or URL. Using a brute force attack, an attacker can guess the session identifier of another user. This can lead to the attacker impersonating the user, retrieving personal information and performing actions on behalf of the user.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11b>

<vuln_items>wasc_11c</vuln_items>
<vuln_item_wasc_11c>
	<alert>Ang Brute Forcing na mga diksiyonaryo at mga file</alert>
	<desc>Ang isang brute force na atake ay isang paraan para pagkuha ng isang hindi alam na halaga sa pamamagitan ng paggamit ng isang awtomasyon na proseso na sumubok ng isang malaking posibilidad na mga halaga. Ang pag-atake ay kumukuha ng kalamangan sa pangyayari na ang entropy sa mga halaga ay maliit sa inaasahan. Halimbawa, habang ang isang 8 karakter na alphanumeric pasword ay maaring magkaroon ng 2.8 trillion na posibleng mga halaga, maraming tao ay pipili sa kanilang mga password mula sa isang maliit na subset na bumubuo ng iisang salita at tuntunin.

Kapag ang mga file nakatira sa mga direktoryo na mga pinaglingkuran sa pamamagitan ng web server pero hindi ito naka-ugnay kung saan, pagpasok sa mga kinakailan na pagkilala sa kanilang pangalan ng file. Sa ilang mga kaso ang mga file na ay naiwan sa pamamagitan ng pagkamali: halimbawa isang backup na awtomatikong file ay nalikha kapag magbago ng isang file o mga iniwan mula sa isang nakaraan na bersyon sa aplikasyon ng web. Sa ibang mga kaso ang mga file ay sadyang iniwan na hindi naka-ugnay bilang isang "seguridad ng karimlan" ang mekanismo na nagpapahintulot lamang sa mga tao na malaman ang pangalan ng file para makapasok ang mga ito.

Ang isang brute force na atake ay sumusubok na maghanap sa hindi naka-ugnay na file sa pamamagitan ng pagsusumikap na pumasok sa mga malalaking numero ng mga file. Ang listahan sa sinusubukang mga pangalan ng file ay maaaring makuha mula sa isang listahan sa kilalang potensyal na mga file o batay sa iba't iba na nakikitang mga file sa web site. Para sa karagdagang impormasyon sa brute forcing na mga direktoryo at mga file ay makikita sa kapanalig na kahinaan, manghuhula ng mapagkunan ng lokasyon.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11c>

<vuln_items>wasc_11d</vuln_items>
<vuln_item_wasc_11d>
	<alert>Brute Forcing sa impormasyon ng credit card</alert>
	<desc>Ang isang brute force na atake ay isang paraan para pagkuha ng isang hindi alam na halaga sa pamamagitan ng paggamit ng isang awtomasyon na proseso na sumubok ng isang malaking posibilidad na mga halaga. Ang pag-atake ay kumukuha ng kalamangan sa pangyayari na ang entropy sa mga halaga ay maliit sa inaasahan. Halimbawa, habang ang isang 8 karakter na alphanumeric pasword ay maaring magkaroon ng 2.8 trillion na posibleng mga halaga, maraming tao ay pipili sa kanilang mga password mula sa isang maliit na subset na bumubuo ng iisang salita at tuntunin.

Pag-shopping online na may nakaw na mga credit card ay kadalasang nangangailangan ng impormasyon sa karagdagan ng numero ng credit card, pinakamadalas ang CVV/SCS at/o ang petsa ng expiration. Ang isang mandadaya ay maaaring humahawak ng isang nakaw na credit card na numero na walang dagdag na impormasyon. Halimbawa ang CVV/CSC ay hindi nakatatak sa card o nakatago sa isang magnetic stripe para hindi ito mabayad sa pamamagitan ng mekanikal o magnetic na credit card swiping na mga kagamitan.

Upang punan ang nawawalang impormasyon ang hacker ay maghuhula ng nawawalang impormasyon gamit ang brute force na pamamaraan, sinusubukan ang lahat ng mga posibleng halaga.
    * Paghuhula ng CVV/CSC ay nangangailangan lamang ng 1000 o 10000 na pagtatangka gaya ng numero ay 3 o 4 digit lamang, depende sa uri ng card.
    * Paghuhula ng petsa ng expiration ay nangangailangan ng ilang dosenang patatangka lamang.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11d>

<vuln_items>wasc_12</vuln_items>
<vuln_item_wasc_12>
	<alert>Spoofing sa nilalaman</alert>
	<desc>Ang nilalaman ng Spoofing ay isang atake sa kakayahan na nagbibigay-daan sa isang magsasalakay upang mag-iniksyon ng isang hindi magandang kargamento na mamaya misrepresented bilang lehitimong nilalaman ng isang web aplikasyon.
 
Ang teksto na nilalaman lamang ng Spoofing
Ang isang pangkaraniwang kakayahan sa mga pahina ng dynamic na pagtatag ay nagsasangkot ng pagpasa sa katawan o mga bahagi nito sa pahina sa pamamagitan ng tanong na halaga ng string. This approach is common on error pages, or sites providing story or news entries. The content specified in this parameter is later reflected into the page to provide the content for the page.
 
Ang Markup Reflected Content Spoofing. Halimbawa, ang pinagkukunan ng lokasyon sa isang frame <frame src="http://foo.example/file.html"/>) ay tinukoy sa pamamagitan ng URL parameter na halaga. (http://foo.example/page?frame_src=http://foo.example/file.html). Ang isang umatake ay maaaring magpalit ng "frame_src" na halaga ng parameter na may "frame_src=http://attacker.example/spoof.html". Hindi tulad ng mga redirector, kapag ang resultang web page ay naglilingkod sa bar lokasyon ng browser na makikita ay maiiwan sa ilalim ng ginagamit na inaasahang domain (foo.example), pero ang dayuhang datos (attacker.example) ay bumabalot ng tunay na nilalaman.

Lalong lalo na ang gawa na mga kaugnay ay pwedeng maipadala ng isang gumagamit gamit ang e-mail, mabilisang mga mensahe, iniwan sa bullentin board na mga posting, o pinipilit sa ibabaw ng mga gumagamit sa pamamagitan ng isang Cross-site Scripting na atake. Kung ang isang umatake ay nakakuhang magbisita ng isang pahina ng web na disenyo na ginagamitan ng kanilang malisyosong URL, ang gumagamit ay maniwala na siya ay tumitingin sa tunay na nilalaman mula sa isang lokasyon kapag siya ay wala. Users will implicitly trust the spoofed content since the browser location bar displays http://foo.example, when in fact the underlying HTML frame is referencing http://attacker.example.

This attack exploits the trust relationship established between the user and the web site. The technique has been used to create fake web pages including login forms, defacements, false press releases, etc.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Content-Spoofing</reference>
	<reference>TBA</reference>
</vuln_item_wasc_12>

<vuln_items>wasc_13</vuln_items>
<vuln_item_wasc_13>
	<alert>Impormasyon na tumagos</alert>
	<desc>Pagtagas ng impormasyon ay isang kahinaan ng aplikasyon na kung saan ang aplikasyon ay nagpapakita ng sensitibong mga datos, tulad ng teknikal na mga detalye sa aplikasyon ng web, kapaligiran, o gumagamit-tumutukoy ng datos. Ang sensitibo na datos ay maaaring gamitin sa pamamagitan ng umatake sa eksployt sa tigpo ng aplikasyon ng web, sa kanyang hosting na network, o sa kanyang mga gumagamit. Samakatuwid, ang pagtagas ng sensitibong datos ay dapat limitado o pumigil hangga't maaari. Pagtagas ng impormasyon, sa kanyang karaniwang anyo, ay ang resulta ng isa o higit pa sa sumusunod na mga kondisyon: Ang isang kabiguan nagkuskos palabas sa HTML/Script na mga komento na naglalaman ng sensitibong impormasyon, hindi wastong aplikasyon o mga kumpigurasyon ng server, o pagkakaiba sa pahina ng mga sagot para sa balido kumpara sa hindi balidong datos.

Kabiguan sa pagkuskus sa HTML/Script na mga komento bago sa isang tulak patungong produksyon ng kapaligiran ay magreresulta sa pagtagas ng sensitibo, kontekswal, impormasyon tulad ng istraktura ng server direktoryo, SQL query na istraktura, at panloob na network na impormasyon. Madalas ang isang developer ay mag-iiwan ng mga komento sa loob ng HTML at/o script code upang makatulong na mapadali ang pagde-debug o pagsasama ng proseso sa panahon ng yugto sa pre-production. Bagama't walang masama sa pagpapahintulot ng mga developer na isama ang nasa linya na mga komento sa loob ng nilalaman na kanilang ginawa, ang mga komentong ito ay dapat lahat alisin bago ang nilalaman sa pampublikong release.

ANg software na bersyon ng mga numero at verbose na maling mga mensahe (tulad ng ASP.NET na mga numero ng bersyon) ay mga halimbawa sa maling server na mga kumpigurasyon. Ang impormasyon na ito ay kapaki-pakinabang sa isang umatake sa pamamagitan ng detalyadong kabatiran sa framework, mga wika, o pre-built na mga function na napapakinabangan ng isang aplikasyon sa web. Karamihan sa default na server na mga kumpigurasyon ay nagbibigay ng software bersyon ng mga numero at verbose na maling mga mensahe para sa pagde-debug at paglutas na mga layunin. Kumpigurasyon ay nagbabago ay maaaring gawin na hindi paganahin ang mga tampok na ito, upang mapigilan ang pagdispley sa impormasyon na ito.

Mga pahina na nagbibigay ng iba't ibang mga tugon batay sa kabuluhan ng datos ay maaari ring humantong sa pagtagas ng impormasyon; lalo na kapag ang datos ay itinuturing na kumpidensyal ay inihayag bilang resulta ng disenyo ng aplikasyon ng web. Mga halimbawa sa sensitibong datos ay kabilang (ngunit hindi limitado sa): mga numero ng account, mga pagkakilanlan ng gumagamit (Numero ng lisensya ng drayber, numero ng passport, mga numero sa social security, atbp.) at gumagamit-partikular na impormasyon (mga password, mga sesyon, mga tirahan). Pagtagas ng impormasyon sa kontekstong ito ay tumatakay sa pagkalantad ng pangunahing gumagamit ng datos na itinuturing na kumpidensyal, o lihim, na dapat hindi nakalantad sa simpleng pananaw, maging ang gumagamit. Ang mga numero ng credit card at iba pang mabigat na regulated na impormasyon ay pangunahing halimbawa ng gumagamit ng datos na nangangailangan ng karagdagang maprotektahan mula sa exposure o pagtagas kahit na may wastong encrypsyon at pagpasok ng mga kontrol na nasa lugar na.</desc>
	<solution>Paghiwa-hiwalayin ang iyong sistema na magkaroon ng "ligtas" na lugar na kung saan ang mga hangganan ng tiwala ay hindi magagalaw o makukuha ng iba. Huwag payagan ang mga sensitibong datos na mag punta sa labas ng pinagkaktiwalaang lugar o lalagyanan at kaialngang lagi ay maging maingat lalo na sa pag interface sa mga kasama sa labas ng ligtas na lalagyan o lugar.</solution>
	<reference>http://projects.webappsec.org/Information-Leakage</reference>
	<reference>http://cwe.mitre.org/data/definitions/200.html</reference>
</vuln_item_wasc_13>

<vuln_items>wasc_14</vuln_items>
<vuln_item_wasc_14>
	<alert>Hindi maayos na kumpigurasyon ng server</alert>
	<desc>Hindi maayos na kumpigurasyon sa server na pag-atake ay pagsamantalahan ng mga kahinaan ng mga server sa web at mga server sa aplikasyon. Maraming mga server ay dumating sa di-kinakailangang default at sample na mga file, kabilang na ang mga aplikasyon, kumpigurasyon na mga file, mga script, at mga pahina ng web. Maaaring mayroon di silang hindi kinakailangang mga serbisyong pinagana, tulad ng pamamahala ng nilalaman at administrasyon ng remote na kakayahan. Pagde-debug na kakayahan ay maaaring mapagana o administrative na mga kakayahan ay maaaring mapasokan sa hindi kilalang mga gumagamit. Mga tampok na ito ay maaaring magbigay ng isang paraan para sa isang hacker na lampasan ang mga pamamaraan ng pagpapatunay at makakuha ng access sa sensitibong impormasyon, marahil may nakataas na mga pribilehiyo.

Mga server ay maaaring magsama ng kilalang default na mga account at mga password. Kabiguan na lubos na i-lock na pababa o patigasin ang server na maaaring iwanan ang pagtakda ng file at mga direktoryo na mga permiso. Hindi maayos na pagkumpigure sa SSL na sertipiko at pag-encryption na mga setting, ang ginagamit sa default na katibayan, at hindi maayos na pagpapatunay na implementasyon na may panlabas na mga sistema ay maaaring ikompromiso ang pagiging kumpidensyal na impormasyon.

Verbose at nakapagtuturo sa maling mga mensahe ay maaaring magresulta sa tulo ng datos, at ang impormasyon ay inihayag ay magagamit sa bumalangkas sa susunod na antas ng atake. Ang maling mga kumpigurasyon sa software ng server ay maaaring magpahintulot sa pag-iindex ng direktoryo at daan sa traversal na mga pag-aatake.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Server-Misconfiguration</reference>
	<reference></reference>
</vuln_item_wasc_14>

<vuln_items>wasc_15</vuln_items>
<vuln_item_wasc_15>
	<alert>Hindi maayos na kumpigurasyon sa aplikasyon</alert>
	<desc>Ang hindi maayos na kumpigurasyon sa aplikasyon na pag-atake ay pagsamatalahan ng mga kahinaan na makikita sa mga aplikasyon sa web. Maraming mga aplikasyon ang dumating na may hindi kinakailangan at hindi ligtas na mga tampok, tulad ng debug at QA na mga tampok, pinagana sa pamamagitan ng default. Mga tampok na ito ay maaaring magbigay ng isang paraan para sa isang hacker na lampasan ang mga pamamaraan ng pagpapatunay at makakuha ng access sa sensitibong impormasyon, marahil may nakataas na mga pribilehiyo.

Likewise, default installations may include well-known usernames and passwords, hard-coded backdoor accounts, special access mechanisms, and incorrect permissions set for files accessible through web servers. Default samples may be accessible in production environments. Application-based configuration files that are not properly locked down may reveal clear text connection strings to the database, and default settings in configuration files may not have been set with security in mind. All of these misconfigurations may lead to unauthorized access to sensitive information.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Application-Misconfiguration</reference>
	<reference></reference>
</vuln_item_wasc_15>

<vuln_items>wasc_16</vuln_items>
<vuln_item_wasc_16>
	<alert>Mga pag-index sa direktoryo</alert>
	<desc>Awtomatikong direktoryo na listahan/indexing ay isang server sa web na tampok na naglilista sa lahat ng mga file sa loob ng isang hiniling na direktoryo kung ang normal na basehan sa file (index.html/home.html/default.htm/default.asp/default.aspx/index.php) ay wala roon. Kapag ang isang gumagamit ay humihingi sa pangunahing pahina sa isang web site, sila ay normal na mag-type sa isang URL tulad ng: http://www.example.com/directory1/ - paggamit ng pangalan ng domain at hindi kasama ang isang partikular na file. Ang web server na mga proseso sa hiling na ito at mga paghahanap ng direktoryo sa dokumento ng root para sa default na panglan ng file at nagpapadala ito ng pahina sa kliyente. Kung ang pahinang ito ay hindi nakaharap, ang server ng web ay magbabago ng isyu sa isang listahan ng direktoryo at nagpapadala ng output sa kliyente. Sa esensya, ito ay katumbas sa pag-isyu ng isang "ls" (Unix) o "dir" (Windows) na utos sa loob ng direktoryo na ito at nagpapakita ng mga resulta sa HTML na form. Mula sa isang atake at countermeasure na perspektibo, ito ay importante na malaman na ang hindi nakaukol na mga listahan ng direktoryo ay maaaring posible ukol sa mga kahinaan sa software (pinag-usapan na seksyon ng halimbawa sa ibaba) pagsamahin na may isang tinutukoy na kahilingan sa web.</desc>
	<solution>Mga rekomendasyon na sinama ang binabawal na pagpasok sa importanteng mga direktoryo at mga file sa pamamagitan ng isang nangangailangan na malaman ang mga kailangan para sa parehong dokumento at root ng server, at pagbaling off na mga tampok tulad ng Awtomatikong Direktoryo na mga listahan na ilandad ang pribadong mga file at nagbibigay ng impormasyon na maaaring magamit ng isang umatake kapag nagbuo o nagsasagawa ng isang pag-aatake.</solution>
	<reference>http://projects.webappsec.org/Directory-Indexing</reference>
	<reference>http://cwe.mitre.org/data/definitions/548.html</reference>
</vuln_item_wasc_16>

<vuln_items>wasc_17</vuln_items>
<vuln_item_wasc_17>
	<alert>Hindi wastong filesystem na mga permiso</alert>
	<desc>Hindi wastong filesystem na mga permiso ay isang banta sa pagiging kumpidensyal, integridad, at magagamit sa isang aplikasyon sa web. Ang problema na lilitaw kapag ang maling filesystem na mga permiso ay nakatakda sa mga file, mga folder, at mga simbolikong link. Kapag hindi wasto ang mga permiso na nakatakda, ang isang umatake ay maaaring makapasok ng restriktong mga file o mga direktoryo at magbabago o magbura sa mga nilalaman. Halimbawa, kung ang isang hindi kilalang gumagamit ng account ay may pahintulot na sumulat sa isang file, pagkatapos ay ang umatake at maaari makagawa na baguhin ang mga nilalaman sa file ng pag-impluwensya sa aplikasyon ng web sa hindi kanais-nais na mga paraan. Ang isang umatake ay maaari ding magsamantala sa hindi wastong mga symlink na escalate ng kanilang mga pribilehiyo at/o pagpasok ng hindi awtorisadong mga file; para sa halimbawa, isang symlink na ang mga puntos sa isang direktoryo sa labas ng web root.</desc>
	<solution>Mabuti na pamahalaan ang mga setting, pamamahala at pagsasagawa ng mga permiso. Pinagtitiwalaan na pagpamamahala ng tiwala na mga zona sa software.</solution>
	<reference>http://projects.webappsec.org/Improper-Filesystem-Permissions</reference>
	<reference>http://cwe.mitre.org/data/definitions/280.html</reference>
</vuln_item_wasc_17>

<vuln_items>wasc_18</vuln_items>
<vuln_item_wasc_18>
	<alert>Ang Credential at Sesyon na hula</alert>
	<desc>Ang Credential/Sesyon na hula ay isang pamamaraan sa hijacking o impersonating sa isang gumagamit ng web site. Pagbabawa o paghula ng natatanging halaga na tinukoy ang isang partikular na sesyon o naisasakatupad ang pag-aatake ng gumagamit. Kilala rin bilang Hijacking na sesyon, ang mga bunga ay magpapahintulot sa mga umaatake na kakayanin ang isyu ng mga kahilingan ng web site na may naka-kompromiso sa pribilehiyo ng gumagamit.

Maraming mga web site ay dinisenyo upang mapatunayan at subaybayan ang isang gumagamit kapag ang kumunikasyon ay unang itinatatag. Upang gawin ito, ang mga gumagamit dapat nagpatunay sa kanilang pagkakakilanlan sa web site, karaniwan ay sa pamamagitan ng pagbibigay ng isang username/password (mga kredensyal) na kumbinasyon. Sa halip na pagpasa ng mga kompidensyal na mga kredensyal pabalik at paatras na may bawat transaksyon, ang mga web site ay bumubuo ng isang natatanging "ID ng sesyon" upang tukuyin ang gumagamit ng sesyon nang mapagtibay. Kasunod na komunikasyon sa pagitan ng gumagamit at sa web site ay naka-tag na may ID ng sesyon bilang "katibayan" sa pagpapatunay na sesyon. Kung ang isang umatake ay kayang mahulaan o hulaan ang ID ng sesyon sa isa pang gumagamit, pandaraya na aktibidad ay posible.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Credential-and-Session-Prediction</reference>
	<reference></reference>
</vuln_item_wasc_18>

<vuln_items>wasc_19</vuln_items>
<vuln_item_wasc_19>
	<alert>SQL Injection</alert>
	<desc>Ang SQL Injection ay isang kakayahan ng pag-atake na ginagamit upang abusohin ang mga aplikasyon na bumuo ng mga pahayag ng SQL mula sa input na ibinigay ng taga-gamit. Kung magiging matagumpay, ang pag-atake ay pwedi mong baguhin ang lohika ng SQL pahayag na isinasagawa kontra sa database.

Ang Structured Query Language (SQL) ay isang espesyal na programang pang lengguwahe para sa pagpapadala ng mga tanong sa mga database. Ang SQL programang pang lengguwahe ay parehong isang ANSI at isang normal na ISO, bagamat maraming mga produkto ng database na suportado ang SQL gawin ito sa mga pagmamay-ari ng lawig sa karaniwang lengguwahe. Ang mga aplikasyon ay kadalasang gumagamit ng datos na ibinigay ng taga-gamit upang gumawa ng mga salaysay ng SQL. Kung ang isang aplikasyon ay nabigo upang maayos na bumuo ng mga SQL na salaysay posible para sa isang pagsalakay upang baguhin ang istraktura ng pahayag at ipatupad ang hindi na plano at potensyal na hahamon sa utos. Kapag ang mga utos na ito ay ipinapatupad, ginagawa nila ito sa ibaba ng konteksto ng taga-gamit na tinukoy ng aplikasyon na ipinapatupad ang salaysay. This capability allows attackers to gain control of all database resources accessible by that user, up to and including the ability to execute commands on the hosting system.</desc>
	<solution>Yugto: Arkitekture at Disenyo
Gamitin ang vetted library o framework na hindi nag papahintulot ng kaninaan para mangyari o nagbibigay constructs na gumagawa ng kahinaan na madaling maiwasan.
Ang halimbawa, kosedirahin ang paggamit ng mga hanay ng pagtitiyaga tulad ng Hibernate o Enterprise Java Beans, na pweding magbigay ng makabuluhang seguridad kontra sa SQL injection kung gagamitin nang maayos.

Kung may magagamit o may mapapakinabangan, gamitin ang structued na mekanismo na awtomatikong mag eenforce ng separado sa pagitan ng datos at code. Ang Mekanismong ito ay maaring mag provide o maghanda ng may kaugnayan sa quoting, pag eencode at sa awtomatikong balidasyon, sa halip na umasa ang mga nag develope ang gumawa ng kapasidad o kakayahan sa lahat ng pagkakataon kapag ang output ay nagenerate.

Process SQL queries using prepared statements, parameterized queries, or stored procedures. These features should accept parameters or variables and support strong typing. Do not dynamically construct and execute query strings within these features using "exec" or similar functionality, since you may re-introduce the possibility of SQL injection.

Run your code using the lowest privileges that are required to accomplish the necessary tasks. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.

Specifically, follow the principle of least privilege when creating user accounts to a SQL database. The database users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others' data. Use the strictest permissions possible on all database objects, such as execute-only for stored procedures.

Ang Yugto: Pagpapatupad
Kung kinakailangan mong gumamit ng mga string ng tanong o direksiyon na dinamiko binuo sa kabila ng panganib, maayos na mag-tukoy
 ng mga argumento at makawala sa anumang mga espesyal na character sa loob ng mga argumento. Ang pinaka-konserbatibong paraan ay upang makawala o mag-sala ng lahat ng mga character na hindi nakapasa sa isang lubos na mahigpit na whitelist (tulad ng lahat ng bagay na hindi alphanumeric o puting patlang). Kung kinakailangan ng mo ng ilang mga espesyal na character, tulad ng puting patlang, balutin ang bawat argumento sa mga panipi pagkatapos ng pagtakas/hakbang sa pagsala. Mag-ingat sa argumento ng injection (CWE-88).

Sa halip na pagbuo ng iyong sariling pagsasagawa, ang mga tampok na ito ay pweding makakuha sa database o lengguwahe ng programa. Ang halimbawa, ang Oracle DBMS ASSERT na pakete ay pweding suriin o isagawa ang mga parameter ay may ilang mga pag-aari na nagpapahina sa kanila sa SQL injection. Para sa MySQL, ang mysql tunay na pag-takas na string() API 
Ang tungkulin ay magagamit sa parehong C at PHP.

Ipagpalagay ang lahat ng input ay malisyoso. Gamitin ang "accept known good"mahusay na pagtanngap at pagkilala o ang pag validate ng input na stratehiya,i.e., gamitin ang puting listahan o whitelist para sa pagtanggap ng ng mga input na striktong sumusunod sa pagtukoy. Tanggihan ang mga input na hindi strikto sa pag conform sa pagtutukoy o sa pag transform nito sa ibang bagay na ginagawa nito. Huwag mag rely sa eksklusibon na pagtingin sa malisyosong o di maayos na input(i.e.,huwag mag rely sa itim na listahan o sa blacklist). Gayon pa man, ang itim na listahan o ang blacklist ay maaaring magamit para sa pagdetect ng potensyal na atake o sa pagtukoy ng mga inputs ay hindi maayos na maaring tanggihan agad.

Kapag ginagamit ang input na validation, iconsider na ang lahat ng potensyal na may kaugnayan sa mga properties, kasama na rito ang haba, tipo ng input, ang buong kakayahan ng pagtanggap ng halaga, kawalan o iba pang inputs, syntax, pagkakapareho sa mga parehong larangan at pagsang-ayon sa mga panuntunan sa negosyo. Bilang isang halimbawa ng lohika sa tuntunin sa negosyo, ang "bangka" ay maaaring tama syntactically dahil naglalaman lamang ito ng mga alphanumeric na character, subalit hindi ito wasto kung umaasa ka sa mga kolor tulad ng "red" o "blue.". Ito ay hindi direktang nalilimitahan ang sakop ng isang pag-atake, subalit ang pamamaraan na ito ay mas mahalaga kaysa sa tamang pag-pasok ng output at pag-alis.

Note that proper output encoding, escaping, and quoting is the most effective solution for preventing SQL injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent SQL injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, the name "O'Reilly" would likely pass the validation step, since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the "'" apostrophe character, which would need to be escaped or otherwise handled. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.

When feasible, it may be safest to disallow meta-characters entirely, instead of escaping them. This will provide some defense in depth. After the data is entered into the database, later processes may neglect to escape meta-characters before use, and you may not have control over those processes.</solution>
	<reference>http://projects.webappsec.org/SQL-Injection</reference>
	<reference></reference>
</vuln_item_wasc_19>

<vuln_items>wasc_20</vuln_items>
<vuln_item_wasc_20>
	<alert>Hindi wastong pagpasok na paghawak</alert>
	<desc>Ang hindi wastong paghawak sa pag-input ay isa sa mga pinakakaraniwang kahinaan na natunton sa buong mga aplikasyon ngayon. Ang hindi magandang pagdederekta sa pag-input ay isang pangunahing dahilan sa likuran ng mga kritikal na kahinaan na umiiral sa mga sistema at aplikasyon.
	
Sa pangkalahatan, ang pangmatagalang pagpasok ng input ay ginagamit upang isalarawan ang mga tungkulin kagaya ng pagpapatunay, sanitization, pag-sasala, pag-papasok at/o pag-labas ng datos ng pag-input. Ang mga aplikasyon ay nakakakuha ng input mula sa iba't ibang mga mapagkukuhaan kasama ang mga taga-gamit ng tao, mga ahente ng software (mga browser), at mga network/peripheral na aparato upang makapagtala ng ilang pangalan. Sa kaso ng mga aplikasyon sa web, pweding mailipat ang input sa iba't ibang mga ayos (name value pairs, JSON, SOAP, etc...) at mkakuha sa pamamagitan ng mga string ng tanong sa URL, POST data, HTTP headers, Cookies, etc... Non-web application input can be obtained via application variables, environment variables, the registry, configuration files, etc... Regardless of the data format or source/location of the input, all input should be considered untrusted and potentially malicious. Applications which process untrusted input may become vulnerable to attacks such as Buffer Overflows, SQL Injection, OS Commanding, Denial of Service just to name a few.

One of the key aspects of input handling is validating that the input satisfies a certain criteria. For proper validation, it is important to identify the form and type of data that is acceptable and expected by the application. Defining an expected format and usage of each instance of untrusted input is required to accurately define restrictions. 

Validation can include checks for type safety and correct syntax. String input can be checked for length (min and max number of characters) and character set validation while numeric input types like integers and decimals can be validated against acceptable upper and lower bound of values. When combining input from multiple sources, validation should be performed during concatenation and not just against the individual data elements. This practice helps avoid situations where input validation may succeed when performed on individual data items but fails when done on a combined set from all the sources.</desc>
	<solution>Yugto: Arkitektura at Disenyo.

Unawain na ang lahat ng potensyal na mga lugar kung saan ang hindi pinagkakatiwalaan na pwedeng magpasok na iyong software: mga parameter at mga argumento, mga cookie, sa anumang mababasa mula sa network, mga variable sa kapaligiran, baliktad na DNS na pagtanaw, mga resulta sa query, mga header ng hiling, mga komponent ng URL, e-mail, mga file, mga database, at anumang panlabas na mga sistema na nagbibigay ng datos sa aplikasyon. Tandaan na ang mga ganong input ay maaaring hindi direktang makuha sa pamamagitan ng mga API call.

For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side. Ang mga umaatake ay maaring bypass sa side ng kliyente suriin ang modipikasyon ng halaga bago pa matapos ang pagsusuri ay magawa, o sa pagbabago ng kliyente sa pagtanggal ng kabuoang pag susuri sa kliyente. Pagkatapos, ang modipikasyon ng halaga ay maaaring ipasa sa server.

Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.

Do not rely exclusively on blacklist validation to detect malicious input or to encode output. There are too many ways to encode the same character, so you're likely to miss some variants.

When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.

Ipagpalagay ang lahat ng input ay malisyoso. Gamitin ang "accept known good"mahusay na pagtanngap at pagkilala o ang pag validate ng input na stratehiya,i.e., gamitin ang puting listahan o whitelist para sa pagtanggap ng ng mga input na striktong sumusunod sa pagtukoy. Tanggihan ang mga input na hindi strikto sa pag conform sa pagtutukoy o sa pag transform nito sa ibang bagay na ginagawa nito. Huwag mag rely sa eksklusibon na pagtingin sa malisyosong o di maayos na input(i.e.,huwag mag rely sa itim na listahan o sa blacklist). Gayon pa man, ang itim na listahan o ang blacklist ay maaaring magamit para sa pagdetect ng potensyal na atake o sa pagtukoy ng mga inputs ay hindi maayos na maaring tanggihan agad.

Kapag ginagamit ang input na validation, iconsider na ang lahat ng potensyal na may kaugnayan sa mga properties, kasama na rito ang haba, tipo ng input, ang buong kakayahan ng pagtanggap ng halaga, kawalan o iba pang inputs, syntax, pagkakapareho sa mga parehong larangan at pagsang-ayon sa mga panuntunan sa negosyo. Bilang isang halimbawa sa negosyo sa panuntunan ng lohika, "bangka" ay may syntactically na balido sapagkat ito lamang ang naglalaman ng alphanumeric na karakter, pero ito ay hindi balido kung ang iyong inaasahang kulay ay "pula" at "asul."

Yugto: Implementasyon

Pakasiguraduhin na ang pagbalido sa iyong ipinasok kapag ang iyong pinalangin na code na tumawid sa wikang mga hangganan, kagaya ng mula sa ipinaliwanag na wika sa likas na code. Ito ay lumilikha ng isang hindi inaasahang interaksyon sa pagitan ng mga linya ng wika. Tiyakin na ikaw ay hindi lumabag sa anumang mga inaasahan ng mga wika na kung saan ikaw ay nag-interfacing. Halimbawa, kahit na ang Java ay hindi maaaring madaling tablan ng buffer na umaapaw, sa pagbibigay ng isang malaking argumento sa isang tawag sa katutubong code na baka mag-trigger ng umaapaw.

Direktang i-convert ang iyong input na uri sa inaasahang datos na uri, tulad ng paggamit ng mga ginagamit na isang pagkagawa ng katungkulan na nagsasalin ng isang string sa isang numero. Matapos ang pag-convert sa uri ng inaasahang uri ng datos, tiyakin na sakop ng mga pinahahalagahan na mga input na mga halaga sa hanay ng pinahihintulutang mga halaga at na ang multi-field ay nagpapanatili na pangalagaan.

Mga pagpasok ay dapat naka-decode at canonicalized sa mga kasalukuyang aplikasyon na panloob na representasyon bago ang pagpapatunay nito. Siguraduhin na ang iyong aplikasyon ay hindi sinasadyang ma-decode ang parehong pagpasok ng dalawang beses. Mga gayong mga kamalian ay maaaring magamit upang lampasan ang whitelist na mga scheme sa pagkilala ng mga panganib sa mga pagpasok matapos na sila ay masiyasat. Gamitin ang aklatan tulad ng sa OWASP ESAPI Canonicalization na control.

Isaalang-alang ang pagsasagawa ng mga paulit-ulit na canonicalization hanggang ang iyong pagpasok ay hindi magbabago kailan man. Ito ay maiwasan ang doble-pagdecode at katulad na mga sitwasyon, ngunit ito ay sinasadyang baguhin ang mga pagpasok na pinapayagan na maglaman ng wastong na-encode na mga panganib na nilalaman.

Kapag ang pagpapalit ng datos sa pagitan ng mga bahagi, masisiguro na ang mga komponent na ginagamit ng parehong karakter na encoding. Tiyakin na ang angkop na pag-encoding ay inilapat sa bawat interface. Pinagtitiwalaang itinakda na pag-encode na iyong ginagamit sa tuwing ang protokol ay nagbibigay-daan sa iyo na gamitin ito.</solution>
	<reference>http://projects.webappsec.org/Improper-Input-Handling</reference>
	<reference>http://cwe.mitre.org/data/definitions/89.html</reference>
</vuln_item_wasc_20>

<vuln_items>wasc_21</vuln_items>
<vuln_item_wasc_21>
	<alert>Hindi sapat na kontra sa awtomasyon</alert>
	<desc>Hindi sapat na kontra-awtomasyon na nangyari kapag ang isang nagpapahintulot ng web aplikasyon ng isang umatake sa awtomatiko na proseso na sa orihinal ay naka disenyo na magsagawa lamang sa isang manwal na kaugalian, hal. sa pamamagitan ng isang taong gumagamit sa web.

Ang aplikasyon ng web na kakayahan na ang mdaalas na target para sa awtomasyon ng mga pag-aatake ay maaaring nagsasali ng:
     * Mga form ng aplikasyon login ‚Äì mga umaatake ay maaaring nag-awtomasyon sa ganid na mga pag-aatake ng pagpasok na mga kahalingan sa isang pagnanais na tumuturing sa user na mga kredential.
    * Ang mga form ng pagpapatala ng serbisyo ‚Äì mga umaatake ay maaaring awtom may awtomatik na maglikha ng libo-libong bagong mga account.
    * Mga form sa email ‚Äì mga umaatake ay maaaring mag-eksployt sa mga form bilang spam attackers may exploit email forms as spam daanan para sa pagbabaha ng mailbox ng isang user.
    * Pagkupkop ng account ‚Äì mga pag-aatake ay maaaring attackers may pagsasagawa ng maraming DoS laban sa isang aplikasyon, sa pamamagitan ng pagbabaha nito gamit ang maraming mga kahilingan para hindi mapagana o mabura ang mga user account
    * Mga form ng impormasyon ng account ‚Äì mga pag-aatake ay maaaring magsagawa mga pagsususbok para kumuha ng personal impormasyon ng user galing isang web na aplikasyon
    * Mga form ng komento / Mga form ng nilalaman ng nabibigay ‚Äì ang mga ito ay maaaring magamit para sa mga spamming sa blog, mga web forum at mga board sa web bulletin sa pamamagitan ng automatikong pagpapadala ng mga nilalaman tulad ng spam o kahit na web-based na malware
    * Mga form na nakatali sa SQL database na mga query - ang mga ito ay maaaring mag-eksployt sa pag-ayos sa paggawa ng isang denial na serbisyo na atake laman sa aplikasyon. Ang atake ay ginanap sa pamamagitan ng pagpapadala ng maraming makapal na SQL na mga query sa isang maikling panahon na oras, samakatuwid na tinatanggihan ang tunay na mga gumagamit mula sa serbisyo.
    * Ang eShopping / Ang eCommerce - Ang eShopping at ang eCommerce na mga aplikasyon na hindi nagpipilit sa tao-lamang na mga mamimili ay pwedeng mag-exployt sa ayos ng bibilhin na mga gustong mga item sa malaking halaga, tulad ng pampalakasan na pangyayari na mga ticket. Ito ay mamayang nagbebenta ng mga scalper para sa matataas ng mga presyo.
    * Ang mga Online poll - mga poll at ibang mga uri sa online na mga pagboto na mga sistema ay awtomatikong mapagsamantalahan na pabor ng isang ilang pagpipilian.
    * Ang Web-based SMS na mensahe ng pagpapadala - mga umaatake ay maaaring mag-exployt ng SMS na mensahe sa mga sistema sa pag-ayos sa spam mobile phone ng mga gumagamit
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Insufficient+Anti-automation</reference>
	<reference>http://cwe.mitre.org/data/definitions/116.html</reference>
</vuln_item_wasc_21>

<vuln_items>wasc_22</vuln_items>
<vuln_item_wasc_22>
	<alert>Hindi wastong paglabas ng paghawak</alert>
	<desc>Paglabas ng paghahawak ng mga tumutukoy sa isang aplikasyon na bumubuo ng paglalabas ng mga datos.  Kung ang isang aplikasyon ay may hindi wastong paglabas na paghawak, ang panglabas na datos ay maaaring kumukuha ng mga kahinaan at mga aksyon na hindi kailanman nilayon ng developer ng aplikasyon.  Sa maraming mga kaso, ang di-sinadyang interpretasyon na ito ay inuri bilang isa o higit pa na mga form ng kritikal na aplikasyon na mga kahinaan.

Anumang lokasyon kung saan ang mga dahon ng datos ng isang aplikasyon na hangganan ay maaring paksa sa hindi wastong panglabas ng paghahawak.  Ang aplikasyon na mga hangganan ay umiiral kung saan ang mga dahon na datos sa isang konteksto at pagpapasok ng iba pa.  Ito ay nagsasama ng mga aplikasyon na nagpapasa ng mga datos sa iba pang mga aplikasyon gamit ang mga serbisyo sa web, mga socket, linya ng command, mga variable ng kapaligiran, atbp...  Ito ay kumakabilang sa pagpapasa ng datos sa pagitan ng hagdan-hagdan sa loob ng isang aplikasyon na arkitektura, tulad ng isang database, direktoryo ng server, HTML/JavaScript na interpreter (browser), o operating system.  Higit na detalye sa kung saan ang hindi maayos na paglabas ng paghahawak ay nangyayari pwedeng matagpuan sa isang seksyon sa ibaba na paksang "Pangkaraniwang Datos na Panglabas ng mga lokasyon".

Ang mga hindi maayos na paglabas na pahahawak ay maaaring tumagal ng iba't ibang anyo sa loob ng isang aplikasyon.  Ang mga form na ito ay maaaring nakategorya sa: mga maling protocol, mga maling apliasyon at mga datos ng konsumer na kaugnay sa mga pagkakamali.  Ang mga maling protokol ay kinabibilangan ng mga nawawala o hindi maayos na paglabas na encoding o pagtakas at paglalabas ng hindi tamang datos.  Ang maling mga aplikasyon ay kinabibilangan ng mga maling lohika tulad ng paglalabas ng hindi tamang datos o pagpapasa sa isang malisyosong nilalaman na hindi naka-filter.  Kung ang aplikasyon ay hindi maayos na makilala ang lehitimong nilalaman mula sa lehitimo, o ito ay hindi gagana ang kilalang mga kahinaan sa datos ng kustomer, ito ay maaaring mag-resulta sa pang-aabuso ng datos-kustomer na sanhi mula sa hindi maayos na paglabas na paghawak.

Ang aplikasyon ay hindi naglalaan ng dayos sa tamang konteksto na maaaring payagan ang isang umatake na abusuhin ang datos ng konsumer.  Ito ay maaaring humantong sa tiyak na mga banta na binanggit sa loob ng WASC Threat na mga Pag-uuri, kabilang ang Content Spoofing, Cross-Site Scripting, HTTP Response Splitting, HTTP Response Smuggling, LDAP Injection, OS Commanding, Routing Detour, Soap Array Abuse, URL Redirector, XML Injection, XQuery Injection, XPath Injection, Mail Command Injection, Null Injection at SQL Injection.

Wastong panglabas na paghahawak ay pinipigil ang hindi inaasahan o di-sinadyang interpretasyon sa datos sa pamamagitan ng mamimili.  Sa pagkakamit ng mithiing ito, ang mga developer ay dapat maunawaan ang modelo ng datos sa aplikasyon, kung papaano ang datos na makuha sa pamamagitan ng ibang bahagi sa aplikasyon, at kung papaano ito huli ipakilala sa gumagamit.  Ang mga teknek para masiguro ang tamang paghawak ng panglabas na kasama ngunit hindi limitado sa pag-filter at sanitasyon sa datos (para sa karagdagang detalye sa panglabas na sanitasyon at pag-filter ay matatagpuan sa angkop na pamagat ng mga seksyon sa ibaba).  Gayunman, hindi pare-pareho ang ginagamit na napiling panglabas na mga teknek na may mataas na panganib sa hindi maayos na panglabas na paghahawak ng datos ay hindi napapansin o hindi nagamot.  Upang matiyak ang "tanggulan sa lalim" ang mga developer ay dapat ipalagay na ang lahat ng mga datos sa loob ng isang aplikasyon ay di-pinagkakatiwalaan kapag pumili ang angkop na panglabas na paghawak na mga estratehiya.

Habang ang wastong panglabas na paghawak ay maaaring tatagal ng iba't ibang mga anyo, ang isang aplikasyon ay hindi maaaring ligtas maliban kung ito ay nagproprotekta laban sa di-sinasadyang mga interpretasyon ng datos sa konsumer. Ang core na kinakailangan na ito ay kinakailangan para sa isang aplikasyon sa matatag na mahawakan ang panglabas na mga operasyon.</desc>
	<solution>Paggamit ng isang vetted na aklatan o balangkas na hindi payagan ang kahinaan nito na mangyari o nagbibigay ng mga contruct na gumagawa ng kahinaan na madaling maiwasan.

Halimbawa, isaalang-alang ang paggamit ang ESAPI Encoding na kontrol o isang katulad na kasangkapan, aklatan, o balangkas. Ito ay makakatulong sa mga programmer na mag-encode ng mga panglabas sa isang paraan na mas madaling kapitan ng mali.

Halili, gamitin ang built-in na mga function, ngunit ang isiping gamitin ang mga wrapper sa kaso ng mga function ay natuklasan na magkakaroon na kahinaan.

Kung may magagamit o may mapapakinabangan, gamitin ang structued na mekanismo na awtomatikong mag eenforce ng separado sa pagitan ng datos at code. Ang Mekanismong ito ay maaring mag provide o maghanda ng may kaugnayan sa quoting, pag eencode at sa awtomatikong balidasyon, sa halip na umasa ang mga nag develope ang gumawa ng kapasidad o kakayahan sa lahat ng pagkakataon kapag ang output ay nagenerate.

For example, stored procedures can enforce database query structure and reduce the likelihood of SQL injection.

Understand the context in which your data will be used and the encoding that will be expected. Ito ay espesyal at importante kapag nag tatransmit o nag papasa ng datos sa pagitan ng mag kaibang components o mga sangkap. o kapag nag gegenerate ng mga output na maaaring may laman na maraming mga encoding sa parehong oras, tulad ng mga pahina sa web o sa maraming parte ng sulat at mensahe. Pag aralan ang lahat na inaasahang komyunikasyon protokol at datos ng representation na makilala o matukoy ang kinikailangang pag eencode at mga estratehiya.

In some cases, input validation may be an important strategy when output encoding is not a complete solution. For example, you may be providing the same output that will be processed by multiple consumers that use different encodings or representations. In other cases, you may be required to allow user-supplied input to contain control information, such as limited HTML tags that support formatting in a wiki or bulletin board. When this type of requirement must be met, use an extremely strict whitelist to limit which control sequences can be used. Verify that the resulting syntactic structure is what you expect. Use your normal encoding methods for the remainder of the input.

Use input validation as a defense-in-depth measure to reduce the likelihood of output encoding errors (see CWE-20).

Kapag ang pagpapalit ng datos sa pagitan ng mga bahagi, masisiguro na ang mga komponent na ginagamit ng parehong karakter na encoding. Tiyakin na ang angkop na pag-encoding ay inilapat sa bawat interface. Pinagtitiwalaang itinakda na pag-encode na iyong ginagamit sa tuwing ang protokol ay nagbibigay-daan sa iyo na gamitin ito.</solution>
	<reference>http://projects.webappsec.org/Improper-Output-Handling</reference>
	<reference></reference>
</vuln_item_wasc_22>

<vuln_items>wasc_23</vuln_items>
<vuln_item_wasc_23>
	<alert>XML Injection</alert>
	<desc>Ang XML Injection ay isang atake na pamamaraan na ginagamit upang manipulahin o ikompromiso ang lohika ng isang XML na aplikasyon o serbisyo. Ang injection sa di-sinasadyang XML na nilalaman at/o mga istruktura para sa isang XML na mensahe na maaaring balakin ang lohika ng aplikasyon. Dagdag pa rito, ang XML Injection ay maaaring maging sanhi ng insertion ng malisyosong nilalaman sa resultang mensahe/dokumento.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/XML-Injection</reference>
	<reference></reference>
</vuln_item_wasc_23>

<vuln_items>wasc_24</vuln_items>
<vuln_item_wasc_24>
	<alert>Ang paghahati ng hiling ng HTTP</alert>
	<desc>Ang paghahati ng hiling ng HTTP ay isang atake na nagpagana na sapilitan sa browser na magpadala ng di-makatwirang HTTP na mga hiling, nagpapatay ng XSS at pagkalason sa cache ng browser. Ang esensya ng atake ay isang kakayahan ng umaatake, sa sandaling ang biktima (browser) ay sapilitang mag-load ng umaatakeng malisyosong HTML na pahina, para manipulahin ang isa sa browser na kakayahan para magpadala ng dalawang HTTP na mga hiling sa halip na isang HTTP na hiling. Ang dalawang gayong na mga mekanismo ay pinagsasamantalahan ang petsa: ang XmlHttpRequest na object (XHR para sa maikli) at ang HTTP digest pagpapatunay na mekanismo. Para sa atake na ito na gagana, ang browser ay dapat gumagamit ng isang pasulong na HTTP proxy (hindi lahat sa kanila "suportahan" ang atake na ito), o ang atake ay dapat isasagawa laban sa isang host na matatagpuan sa isang parehong IP (mula sa pananaw ng browser) na may makina ng umaatake.</desc>
	<solution>Iwasan ang paggamit ng CRLF bilang isang espesyal na pagkasunod-sunod. Angkop na filter o quote na CRLF na sunod-sunod sa gumagamit-kontrolado na pagpasok.</solution>
	<reference>http://projects.webappsec.org/HTTP-Request-Splitting</reference>
	<reference>http://cwe.mitre.org/data/definitions/93.html</reference>
</vuln_item_wasc_24>

<vuln_items>wasc_25</vuln_items>
<vuln_item_wasc_25>
	<alert>Ang paghahati ng hiling ng HTTP</alert>
	<desc>Sa paghahati ng hiling ng HTTP na atake, laging may mga tatlong partido (kahit) kasangkot: * Ang Web server, na kung saan ang isang seguridad na butas ay pinagana ang paghahati ng haling ng HTTP * Ang target - isang entidad na naikipag-ugnayan sa server ng web marahil sa umaatake. Ito ay karaniwang na isang cache na server na pasulong/pabalik na proxy), o isang browser (marahil na may isang cache ng browser).
    * Ang umaatake - nagsisismula ng pag-aatake

Ang katangian sa HTTP na hiling na paghihiway ay isang abilidad ng umaatake na magpapadala ng isang mag-isa na HTTP na hiling na pumuwersa sa web server na form sa panglabas ng stream, na kung saan ay nagpapaliwanag sa pamamagitan ng target at bilang dalawang HTTP na mga hiling sa halip na isa sa normal na kaso. Ang unang sagot ay bahagyang kinokontrol sa umatake, ngunit ito ay hindi gaanong mahalaga. Ang materyal ay ang umatake ay ganap na kinokontrol ang form sa pangalawang sagot mula sa katangian ng HTTP na linya sa huling byte sa HTTP na sagot ng katawan. Sa sandaling ito ay posible, ang umaatake ay nagsagawa ng atake sa pamamagitan ng pagpadala ng dalawang mga hiling hanggang sa target. Ang unang mag-isa na tinatawag ang dalawang mga tugon mula sa web server, at ang pangalawang kahilingan na karamihan ay maraming "inosente" napagkukunan ng web server. Gayunman, ang pangalawang kahilingan ay tumugma, sa pamamagitan ng target, ang pangalawang HTTP na sagot, na kung saan ay ganap na kinokontrol sa umaatake. Ang umaatake, samakatuwid, ang mga pagdaya sa target sa paniniwala na ang isang partikular na pagkukunan sa web server (itinatalaga ng pangalawang kahilingan) ay ang sagot ng HTTP (nilalaman ng server), habang ito ay sa katunayan ang karamihan sa datos, na kung saan ay binuo sa pamamagitan ng pag-atake sa pamamagitan ng web server - ito ay ang ikalawang tugon.

Ang HTTP hinahating tugon na pag-aatake ay ang magpapalit na kung saan ang server na script ay naglalagay ng user data sa tugon ng HTTP. Ang tipikal na mga pangyayari na kapag ang script ay naglalagay ng user data sa redirection URL sa isang redirection na tugon (HTTP na katangian code 3xx), o kapag ang script ay naglalagay ng user data sa isang cookie na halaga o pangalan kapag ang tugon ay nagtatakda ng isang cookie.</desc>
	<solution>Bumuo ng HTTP na mga header ay mabuting pinag-iingatan, pag-iwas sa paggamit ng di-napatunayan na pagpapasok ng datos.</solution>
	<reference>http://projects.webappsec.org/HTTP-Response-Splitting</reference>
	<reference>http://cwe.mitre.org/data/definitions/113.html</reference>
</vuln_item_wasc_25>

<vuln_items>wasc_26</vuln_items>
<vuln_item_wasc_26>
	<alert>Ang paghahati ng hiling ng HTTP</alert>
	<desc>Ang Hiling ng smuggling ay isang pamamaraan ng pag-atake na umaabuso sa pagkakaiba sa parsing sa hindi RFC na daing na HTTP na mga kahilingan sa pagitan ng dalawang HTTP na mga kagamitan (karaniwang isang front-end na proxy o HTTP-pinagana na firewall at isang back-end na web server) upang ilusot ang isang kahilingan sa ikalawang kagamitan "sa pamamagitan" ng unang aparato. Ang teknek ay nagbibigay-daan sa umaatake sa nagpapadala ng isa sa mga kahilingan sa pangalawang kagamitan samantalang ang unang kagamitan ay nakakita ng iba't ibang itinakda na mga kahilingan. Sa pag-ikot, ito ay gumagamit ng maraming posibleng mga eksployt, tulad ng partial na cache na paglalason, bypassing sa proteksyon ng firewall at XSS.</desc>
	<solution>Gamitin ang isang web server na tungkulin ang isang estriko na HTTP parsing na pamamalakad. tulad ng Apache (TIngnan ang papel sa itinutukoy).

Gamitin lamang ang SSL na komunikasyon.

Wakasin ang sesyon ng kliyente pagkatapos ng bawat kahilingan.

Ikutin ang lahat na pahina ng hindi cacheable.</solution>
	<reference>http://projects.webappsec.org/HTTP-Request-Smuggling</reference>
	<reference>http://cwe.mitre.org/data/definitions/444.html</reference>
</vuln_item_wasc_26>

<vuln_items>wasc_27</vuln_items>
<vuln_item_wasc_27>
	<alert>Ang smuggling ng hiling ng HTTP</alert>
	<desc>Ang HTTP smuggling na sagot ay isang pamamaraan sa "smuggle" dalawang HTTP na mga sagot mula sa isang server hanggang sa kliyente, sa pamamagitan ng intermediary HTTP na kagamitan na tumitingin (o pumapayag) ng isang sagot mula sa server.

Ang isang gumagamit para sa teknek na ito ay isang pagtitibay sa basic na HTTP na sagot ng paghihiwalay na pamamaraan sa pag-ayos sa pag-iwas ng anti-HTTP na tugong nagpapahiwalay na mga sukat. Sa kasong ito, ang intermediary ay isang anti-HTTP na sagot ng paghihiwalay na mekanismo sa pagitan ng webserver at ng proxy server (o web browser). Ibang gamit sa kaso ay sa spoof na mga sagot na natatanggap ng browser. Sa kasong ito ang isang malisyosong web site ay naglilingkod ng browser ng pahina na ang browser ay nagpapaliwanay bilang orihinal mula sa isang kaibang (target) na domain. Ang HTTP na tugon ng smuggling ay pwedeng magamit sa pagkamit ng ganito sa browser na gumagamit ng isang proxy server sa pagpasok sa kapwa mga site.

Ang HTTP na tugon ng smuggling ay gumagamit ng HTTP na hiling ng smuggling -tulad ng mga pamamaraan upang pagsamantalahan ang pagkakaiba sa pagitan na kong ano ang anti- HTTP na tugon na paghihiwalay na mekanismo (o isang proxy server) na magiging isaalang-alangsa HTTP na tugon ng stream, at ang sagot na stream na gaya ng proxy server (o isang browser). Kaya, habang ang anti- HTTP na tugon ng paghihiwalay na mekanismo ay maaaring isaalang-alang ng isang partikular na tugon ng stream na di nakasasama (solong HTTP na tugon), isang proxy/browser ay maaaring i-parse pa rin bilang dalawang HTTP na mga sagot, at kaya mahilig sa lahat ng mga kinalalabasan sa orihinal na HTTP na tugon ng paghihiwalay na pamamaraan ( sa unang paggamit ng kaso) o maging madaling kapitan sa pahinang spoofing (sa pangalawang kaso). Halimbawa, ang ilang anti- HTTP na tugon ng naghahating mga mekanismo na ginagamit ng ilang mga aplikasyon ng mga makinarya na ipinagbabawal ang aplikasyon mula sa pagpasok ng isang header na naglalaman ng CR+LF na sagot. Gayon man ang umaatake ay maaaring pumipilit sa aplikasyon sa pagsingit sa isang header na naglalaman ng CRs, nang sa gayon ay circumventing sa pagtatanggol ng mekanismo. Ilang proxy na mga server ay maaaring maging treat CR (lamang) bilang isang header (at sagot) ng tagahiwalay, at bilang tulad ang kumbinasyon sa web server at proxy server ay maging vulnerable sa isang pag-aatake na maaaring maglason sa cache ng proxy.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/HTTP-Response-Smuggling</reference>
	<reference></reference>
</vuln_item_wasc_27>

<vuln_items>wasc_28</vuln_items>
<vuln_item_wasc_28>
	<alert>Null Byte na injection</alert>
	<desc>Ang Null Byte na injection ay isang aktibong eksploytasyon na pamamaraan na ginagamit sa pag-iwas sa sanity na pagtitingin ng mga filter sa web imprastraktura sa pamamagitan ng pagdaragdag ng URL-encode null byte na mga karakter (hal. %00, o 0x00 sa hex) na ang gumagamit-idinulot na datos. Ang injection na proseso ay maaaring baguhin ang mismong lohika ng aplikasyon at pinapayagan ang malisyosong kaaway upang makakuha ng hindi awtorisadong access ng sistema ng mga file.

Karamihan ng web na mga aplikasyon sa ngayon ay binuo sa paggamit ng mataas-antas na mga wika tulad ng, PHP, ASP, Perl, at Java. Gayunman, ang mga web na mga aplikasyon sa ilang punto na nangangailangan ng pagproseso ng mataas-antas na code at sistema na antas at itong proseso na kadalasan maisasagawa sa pamamagitan ng paggamit ng ‚ÄòC/C++‚Äô ng mga function. Ang iba't ibang katangian na umaasa ng mga teknolohiya na ito ay nagrersulta sa isang klase ng pag-atake na tinatawag na ‚ÄòNull Byte Injection‚Äô o ‚ÄòNull Byte Poisoning‚Äô na atake. Sa C/C++, ang isang null byte ay kumakatawan ng string na terminasyon na punto o delimiter na karakter na ibig sabihin ay ihinto ang pagpoproseso ng string kaagad. Mga byte na sumusunod sa delimiter ay hindi papansinin. Kung ang string ay nagbabawas ng kanyang null karakter, ang haba ng isang string ay nagiging hindi kilala hanggang ang memory na panturo ay nangyayari upang matagpuan ang susunod na zero byte. Ang di-sinasadyang ramification ay maaaring magdulot ng kakaibang kilos at pagkilala ng mga kahinaan sa loob ng sistema o saklaw ng aplikasyon. Sa kahalintulad na mga kataga, ilang mataas-na antas ng mga wika na itinuturing ‚Äònull byte‚Äô bilang isang placeholder para sa haba ng string kapag ito ay walang espesyal na kahulugan sa kanilang konteksto. Dahil ditong pagkakaiba na interpretasyon, ang null bytes ay maaaring madaling ma-inject upang manipulahin ang isang pag-uugali ng aplikasyon.

Ang mga URL ay limitado sa isang itinakda sa US-ASCII na mga karakter mula sa 0x20 hanggang 0x7E (hex) o 32 hanggang 126 (decimal). Gayunman, ang nabanggit na hanay ay ginagamit ng ilang mga karakter na hindi pinahihintulutan dahil sila ay may espesyal na kahulugan sa loob ng HTTP protocol na konteksto. Para sa kadahilanang ito, ang URL na encoding scheme ay ipinakilala na naglalaman ng mga karakter sa loob ng URL na gamit ang pinalawig na ASCII katakter na representasyon. Sa termino ng ‚Äúnull byte‚Äù, ito ay kumakatawan bilang %00 sa hexadecimal. Ang saklaw sa iang null byte na atake ay nagsisimula na kung saan ang mga web aplikasyon ay kumakausap sa aktibong ‚ÄòC‚Äô na mga routine at panglabas na APIs mula sa kalakip na OS. Kaya, nagpapahintulot ang umatake na manipulahin ang pagkukunan ng web sa pamamagitan ng pagbasa o pagsulat ng mga file batay sa pribilehiyo ng gumagammit ng mga aplikasyon.</desc>
	<solution>Developers should anticipate that null characters or null bytes will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and white lists to ensure only valid, expected and appropriate input is processed by the system.

Ipagpalagay ang lahat ng input ay malisyoso. Use a standard input validation mechanism to validate all input for length, type, syntax, and business rules before accepting the data to be displayed or stored. Use an "accept known good" validation strategy.

Use and specify a strong output encoding (such as ISO 8859-1 or UTF 8).

Do not rely exclusively on blacklist validation to detect malicious input or to encode output. There are too many variants to encode a character; you're likely to miss some variants.

Mga pagpasok ay dapat naka-decode at canonicalized sa mga kasalukuyang aplikasyon na panloob na representasyon bago ang pagpapatunay nito. Make sure that your application does not decode the same input twice. Mga gayong mga kamalian ay maaaring magamit upang lampasan ang whitelist na mga scheme sa pagkilala ng mga panganib sa mga pagpasok matapos na sila ay masiyasat.</solution>
	<reference>http://projects.webappsec.org/Null-Byte-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/158.html</reference>
</vuln_item_wasc_28>

<vuln_items>wasc_29</vuln_items>
<vuln_item_wasc_29>
	<alert>LDAP Injection</alert>
	<desc>Ang LDAP injection ay isang pamamaraan sa pag-atake na gumagamit ng pag-aabuso ng mga web site na bumubuo ng LDAP na mga pahayag mula sa gumagamit-nagbibigay ng pagpasok.

Ang Lightweight Directory Access Protocol (LDAP) ay isang bukas-standard na protokol para sa bawat querying at pagmanipula sa X.500 na direktoryo ng mga serbisyo. Ang LDAP na protokol ay tumatakbo sa ibabaw ng internet transport na mga protokol, tulad ng TCP. Ang mga web aplikasyon ay maaaring gumgamit ng gumagamit-nagbibigay na pagpasok upang lumikha ng custom LDAP na mga pahayag para sa pabago bago na web page na mga kahilingan.

Kapag ang isang web aplikasyon ay bumagsak sa maayos na sanitize gumagamit-nagbibigay na pagpasok, ito ay posible para sa isang umatake na baguhin ang ginawa sa isang LDAP na pahayag. Kapag ang isang umatake ay may kaya na baguhin ang isang LDAP na pahayag, ang proseso ay tatakbo gamit ang magkaparehong mga pahintulot na ang komponent na nagsasagawa ng utos. (hal. Ang database server, web aplikasyon na server, ang web server, atbp.). Ito ay sanhi sa seryosong seguridad na mga problema na kung saan ang mga pahintulot ay pumapayag sa karapatan ng query, magbago o magbura ng anumang nasa loob ng LDAP tree. Ang parehong advanced na pagsasamantala na mga pamamaraan na magagamit sa SQL Injection ay maaaring parehong ginamit sa LDAP Injection.</desc>
	<solution>Assume all input is malicious. Use an appropriate combination of black lists and white lists to neutralize LDAP syntax from user-controlled input.</solution>
	<reference>http://projects.webappsec.org/LDAP-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/90.html</reference>
</vuln_item_wasc_29>

<vuln_items>wasc_30</vuln_items>
<vuln_item_wasc_30>
	<alert>Mail Command Injection</alert>
	<desc>Mail Command Injection is an attack technique used to exploit mail servers and webmail applications that construct IMAP/SMTP statements from user-supplied input that is not properly sanitized. Depending on the type of statement taken advantage by the attacker, we meet two types of injections: IMAP and SMTP Injection. An IMAP/SMTP Injection may make it possible to access a mail server which you previously had no access to before-hand. In some cases, these internal systems do not have the same level of infrastructure security hardening applied to them as most front-end web servers. Hence, attackers may find that the mail server yields better results in terms of exploitation. On the other hand, this technique allows to evade possible restrictions that could exist at application level (CAPTCHA, maximum number of requests, etc.).</desc>
	<solution>Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, request headers as well as content, URL components, e-mail, files, databases, and any external systems that provide data to the application. Perform input validation at well-defined interfaces.

Ipagpalagay ang lahat ng input ay malisyoso. Use an "accept known good" input validation strategy (i.e., use a whitelist). Tanggihan ang mga input na hindi strikto sa pag conform sa pagtutukoy o sa pag transform nito sa ibang bagay na ginagawa nito. Use a blacklist to reject any unexpected inputs and detect potential attacks.

Do not rely exclusively on blacklist validation to detect malicious input or to encode output. There are too many ways to encode the same character, so you're likely to miss some variants.

Direktang i-convert ang iyong input na uri sa inaasahang datos na uri, tulad ng paggamit ng mga ginagamit na isang pagkagawa ng katungkulan na nagsasalin ng isang string sa isang numero. Matapos ang pag-convert sa uri ng inaasahang uri ng datos, tiyakin na sakop ng mga pinahahalagahan na mga input na mga halaga sa hanay ng pinahihintulutang mga halaga at na ang multi-field ay nagpapanatili na pangalagaan.

Mga pagpasok ay dapat naka-decode at canonicalized sa mga kasalukuyang aplikasyon na panloob na representasyon bago ang pagpapatunay nito. Make sure that your application does not inadvertently decode the same input twice . Mga gayong mga kamalian ay maaaring magamit upang lampasan ang whitelist na mga scheme sa pagkilala ng mga panganib sa mga pagpasok matapos na sila ay masiyasat. Gamitin ang aklatan tulad ng sa OWASP ESAPI Canonicalization na control.

Isaalang-alang ang pagsasagawa ng mga paulit-ulit na canonicalization hanggang ang iyong pagpasok ay hindi magbabago kailan man. Ito ay maiwasan ang doble-pagdecode at katulad na mga sitwasyon, ngunit ito ay sinasadyang baguhin ang mga pagpasok na pinapayagan na maglaman ng wastong na-encode na mga panganib na nilalaman.

Kapag ang pagpapalit ng datos sa pagitan ng mga bahagi, masisiguro na ang mga komponent na ginagamit ng parehong karakter na encoding. Tiyakin na ang angkop na pag-encoding ay inilapat sa bawat interface. Pinagtitiwalaang itinakda na pag-encode na iyong ginagamit sa tuwing ang protokol ay nagbibigay-daan sa iyo na gamitin ito.

When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.</solution>
	<reference>http://projects.webappsec.org/Mail-Command-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/88.html</reference>
</vuln_item_wasc_30>

<vuln_items>wasc_31</vuln_items>
<vuln_item_wasc_31>
	<alert>Ang OS Commanding</alert>
	<desc>Ang OS Commanding ay isang pamamaraan sa pag-aatake na ginamit para sa awtorisadong nagsasagawa sa operating system na mga command.

Ang OS Commanding ay isang direktang resulta sa halo-halo ng pinagkakatiwalaan na code at hindi pinagkakatiwalaan na datos. This attack is possible when an application accepts untrusted input to build operating system commands in an insecure manner involving improper data sanitization, and/or improper calling of external programs. In OS Commanding, executed commands by an attacker will run with the same privileges of the component that executed the command, (e.g. database server, web application server, web server, wrapper, application). Since the commands are executed under the privileges of the executing component an attacker can leverage this to gain access or damage parts that are otherwise unreachable (e.g. the operating system directories and files).</desc>
	<solution>If at all possible, use library calls rather than external processes to recreate the desired functionality.

Run your code in a "jail" or similar sandbox environment that enforces strict boundaries between the process and the operating system. Ito ay maaring epektibong restrict kung saan ang files ay pwedeng magamit sa partikular na directory o kung saan ang utos ay maaring magamit o maisagawa ng iyong software.

Ang OS-level ay mga ehemplo na kasama ang Unix chroot jail. AppArmor, at SELinux. Sa pangakalahatan, ang pag mamanage ng code ay pwedeng magbigay ng ilang proteksyon. Halimbawa, java.io FilePermission sa mga Java SecurityManager na mag aallow sayo ng pagtukoy sa mga restrictions o sa mga mahigpit na file na operasyon.
Ito ay maaring di magawan ng solusyon, at ito ay limitasyon sa pag impact ng mga sitemang nag ooperate; at ang lahat ng iyong aplikasyon ay maaring maging paksa para sa kompormiso.

For any data that will be used to generate a command to be executed, keep as much of that data out of external control as possible. For example, in web applications, this may require storing the command locally in the session's state instead of sending it out to the client in a hidden form field.

Paggamit ng isang vetted na aklatan o balangkas na hindi payagan ang kahinaan nito na mangyari o nagbibigay ng mga contruct na gumagawa ng kahinaan na madaling maiwasan.

Halimbawa, isaalang-alang ang paggamit ang ESAPI Encoding na kontrol o isang katulad na kasangkapan, aklatan, o balangkas. Ito ay makakatulong sa mga programmer na mag-encode ng mga panglabas sa isang paraan na mas madaling kapitan ng mali.

If you need to use dynamically-generated query strings or commands in spite of the risk, properly quote arguments and escape any special characters within those arguments. Ang pinaka-konserbatibong paraan ay upang makawala o mag-sala ng lahat ng mga character na hindi nakapasa sa isang lubos na mahigpit na whitelist (tulad ng lahat ng bagay na hindi alphanumeric o puting patlang). Kung kinakailangan ng mo ng ilang mga espesyal na character, tulad ng puting patlang, balutin ang bawat argumento sa mga panipi pagkatapos ng pagtakas/hakbang sa pagsala. Be careful of argument injection.

If the program to be executed allows arguments to be specified within an input file or from standard input, then consider using that mode to pass arguments instead of the command line.

Kung may magagamit o may mapapakinabangan, gamitin ang structued na mekanismo na awtomatikong mag eenforce ng separado sa pagitan ng datos at code. Ang Mekanismong ito ay maaring mag provide o maghanda ng may kaugnayan sa quoting, pag eencode at sa awtomatikong balidasyon, sa halip na umasa ang mga nag develope ang gumawa ng kapasidad o kakayahan sa lahat ng pagkakataon kapag ang output ay nagenerate.

Some languages offer multiple functions that can be used to invoke commands. Where possible, identify any function that invokes a command shell using a single string, and replace it with a function that requires individual arguments. These functions typically perform appropriate quoting and filtering of arguments. For example, in C, the system() function accepts a string that contains the entire command to be executed, whereas execl(), execve(), and others require an array of strings, one for each argument. In Windows, CreateProcess() only accepts one command at a time. In Perl, if system() is provided with an array of arguments, then it will quote each of the arguments.

Ipagpalagay ang lahat ng input ay malisyoso. Gamitin ang "accept known good"mahusay na pagtanngap at pagkilala o ang pag validate ng input na stratehiya,i.e., gamitin ang puting listahan o whitelist para sa pagtanggap ng ng mga input na striktong sumusunod sa pagtukoy. Tanggihan ang mga input na hindi strikto sa pag conform sa pagtutukoy o sa pag transform nito sa ibang bagay na ginagawa nito. Huwag mag rely sa eksklusibon na pagtingin sa malisyosong o di maayos na input(i.e.,huwag mag rely sa itim na listahan o sa blacklist). Gayon pa man, ang itim na listahan o ang blacklist ay maaaring magamit para sa pagdetect ng potensyal na atake o sa pagtukoy ng mga inputs ay hindi maayos na maaring tanggihan agad.

Kapag ginagamit ang input na validation, iconsider na ang lahat ng potensyal na may kaugnayan sa mga properties, kasama na rito ang haba, tipo ng input, ang buong kakayahan ng pagtanggap ng halaga, kawalan o iba pang inputs, syntax, pagkakapareho sa mga parehong larangan at pagsang-ayon sa mga panuntunan sa negosyo. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as "red" or "blue."

When constructing OS command strings, use stringent whitelists that limit the character set based on the expected value of the parameter in the request. Ito ay hindi direktang nalilimitahan ang sakop ng isang pag-atake, subalit ang pamamaraan na ito ay mas mahalaga kaysa sa tamang pag-pasok ng output at pag-alis.

Note that proper output encoding, escaping, and quoting is the most effective solution for preventing OS command injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent OS command injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, when invoking a mail program, you might need to allow the subject field to contain otherwise-dangerous inputs like ";" and ">" characters, which would need to be escaped or otherwise handled. In this case, stripping the character might reduce the risk of OS command injection, but it would produce incorrect behavior because the subject field would not be recorded as the user intended. This might seem to be a minor inconvenience, but it could be more important when the program relies on well-structured subject lines in order to pass messages to other components.

Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.</solution>
	<reference>http://projects.webappsec.org/OS-Commanding</reference>
	<reference>http://cwe.mitre.org/data/definitions/78.html</reference>
</vuln_item_wasc_31>

<vuln_items>wasc_32</vuln_items>
<vuln_item_wasc_32>
	<alert>Routing Detour</alert>
	<desc>The WS-Routing Protocol (WS-Routing) is a protocol for exchanging SOAP messages from an initial message sender to an ultimate receiver, typically via a set of intermediaries. The WS-Routing protocol is implemented as a SOAP extension, and is embedded in the SOAP Header. WS-Routing is often used to provide a way to direct XML traffic through complex environments and transactions by allowing interim way stations in the XML path to assign routing instructions to an XML document.

Routing Detours are a type of "Man in the Middle" attack where Intermediaries can be injected or "hijacked" to route sensitive messages to an outside location. Routing information (either in the HTTP header or in WS-Routing header) can be modified en route and traces of the routing can be removed from the header and message such that the receiving application none the wiser that a routing detour has occurred. The header and the insertion of header objects is often less protected than the message; this is due to the fact that the header is used as a catch all for metadata about the transaction such as authentication, routing, formatting, schema, canonicalization, namespaces, etc. Also, many processes may be involved in adding to/processing the header of an XML document. In many implementations the routing info can come from an external web service (using WS-Referral for example) that provides the specific routing for the transaction.

WS-Addressing is a newer standard published by the W3C to provide routing functionality to SOAP messages. One of the key differences between WS-Routing and WS-Addressing is that WS-Addressing only provides the next location in the route. While little research has been done into the susceptibility of WS-Addressing to Routing Detour Attack, at least one paper (see reference #6 below) suggests that WS-Addressing is vulnerable to Routing Detour as well.</desc>
	<solution>Always fully authenticate both ends of any communications channel.

Adhere to the principle of complete mediation.

A certificate binds an identity to a cryptographic key to authenticate a communicating party. Often, the certificate takes the encrypted form of the hash of the identity of the subject, the public key, and information such as time of issue or expiration using the issuer's private key. The certificate can be validated by deciphering the certificate with the issuer's public key. See also X.509 certificate signature chains and the PGP certification structure.</solution>
	<reference>http://projects.webappsec.org/Routing-Detour</reference>
	<reference>http://cwe.mitre.org/data/definitions/300.html</reference>
</vuln_item_wasc_32>

<vuln_items>wasc_33</vuln_items>
<vuln_item_wasc_33>
	<alert>Path Traversal</alert>
	<desc>The Path Traversal attack technique allows an attacker access to files, directories, and commands that potentially reside outside the web document root directory. An attacker may manipulate a URL in such a way that the web site will execute or reveal the contents of arbitrary files anywhere on the web server. Any device that exposes an HTTP-based interface is potentially vulnerable to Path Traversal.

Most web sites restrict user access to a specific portion of the file-system, typically called the "web document root" or "CGI root" directory. These directories contain the files intended for user access and the executable necessary to drive web application functionality. To access files or execute commands anywhere on the file-system, Path Traversal attacks will utilize the ability of special-characters sequences.

The most basic Path Traversal attack uses the "../" special-character sequence to alter the resource location requested in the URL. Although most popular web servers will prevent this technique from escaping the web document root, alternate encodings of the "../" sequence may help bypass the security filters. These method variations include valid and invalid Unicode-encoding ("..%u2216" or "..%c0%af") of the forward slash character, backslash characters ("..\") on Windows-based servers, URL encoded characters "%2e%2e%2f"), and double URL encoding ("..%255c") of the backslash character.

Even if the web server properly restricts Path Traversal attempts in the URL path, a web application itself may still be vulnerable due to improper handling of user-supplied input. This is a common problem of web applications that use template mechanisms or load static text from files. In variations of the attack, the original URL parameter value is substituted with the file name of one of the web application's dynamic scripts. Consequently, the results can reveal source code because the file is interpreted as text instead of an executable script. These techniques often employ additional special characters such as the dot (".") to reveal the listing of the current working directory, or "%00" NULL characters in order to bypass rudimentary file extension checks.</desc>
	<solution>Ipagpalagay ang lahat ng input ay malisyoso. Gamitin ang "accept known good"mahusay na pagtanngap at pagkilala o ang pag validate ng input na stratehiya,i.e., gamitin ang puting listahan o whitelist para sa pagtanggap ng ng mga input na striktong sumusunod sa pagtukoy. Tanggihan ang mga input na hindi strikto sa pag conform sa pagtutukoy o sa pag transform nito sa ibang bagay na ginagawa nito. Huwag mag rely sa eksklusibon na pagtingin sa malisyosong o di maayos na input(i.e.,huwag mag rely sa itim na listahan o sa blacklist). Gayon pa man, ang itim na listahan o ang blacklist ay maaaring magamit para sa pagdetect ng potensyal na atake o sa pagtukoy ng mga inputs ay hindi maayos na maaring tanggihan agad.

Kapag ginagamit ang input na validation, iconsider na ang lahat ng potensyal na may kaugnayan sa mga properties, kasama na rito ang haba, tipo ng input, ang buong kakayahan ng pagtanggap ng halaga, kawalan o iba pang inputs, syntax, pagkakapareho sa mga parehong larangan at pagsang-ayon sa mga panuntunan sa negosyo. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as "red" or "blue."

For filenames, use stringent whitelists that limit the character set to be used. If feasible, only allow a single "." character in the filename to avoid weaknesses, and exclude directory separators such as "/". Use a whitelist of allowable file extensions.

Warning: if you attempt to cleanse your data, then do so that the end result is not in the form that can be dangerous. A sanitizing mechanism can remove characters such as '.' and ';' which may be required for some exploits. An attacker can try to fool the sanitizing mechanism into "cleaning" data into a dangerous form. Suppose the attacker injects a '.' inside a filename (e.g. "sensi.tiveFile") and the sanitizing mechanism removes the character resulting in the valid filename, "sensitiveFile". If the input data are now assumed to be safe, then the file may be compromised. 

Mga pagpasok ay dapat naka-decode at canonicalized sa mga kasalukuyang aplikasyon na panloob na representasyon bago ang pagpapatunay nito. Make sure that your application does not decode the same input twice. Mga gayong mga kamalian ay maaaring magamit upang lampasan ang whitelist na mga scheme sa pagkilala ng mga panganib sa mga pagpasok matapos na sila ay masiyasat.

Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes ".." sequences and symbolic links.

Run your code using the lowest privileges that are required to accomplish the necessary tasks. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.

When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.

Run your code in a "jail" or similar sandbox environment that enforces strict boundaries between the process and the operating system. Ito ay maaring epektibong restrict kung saan ang files ay pwedeng magamit sa partikular na directory o kung saan ang utos ay maaring magamit o maisagawa ng iyong software.

Ang OS-level ay mga ehemplo na kasama ang Unix chroot jail. AppArmor, at SELinux. Sa pangakalahatan, ang pag mamanage ng code ay pwedeng magbigay ng ilang proteksyon. Halimbawa, java.io FilePermission sa mga Java SecurityManager na mag aallow sayo ng pagtukoy sa mga restrictions o sa mga mahigpit na file na operasyon.

Ito ay maaring di magawan ng solusyon, at ito ay limitasyon sa pag impact ng mga sitemang nag ooperate; at ang lahat ng iyong aplikasyon ay maaring maging paksa para sa kompormiso.
</solution>
	<reference>http://projects.webappsec.org/Path-Traversal</reference>
	<reference>http://cwe.mitre.org/data/definitions/22.html</reference>
</vuln_item_wasc_33>

<vuln_items>wasc_34</vuln_items>
<vuln_item_wasc_34>
	<alert>Predictable Resource Location</alert>
	<desc>Predictable Resource Location is an attack technique used to uncover hidden web site content and functionality. By making educated guesses via brute forcing an attacker can guess file and directory names not intended for public viewing. Brute forcing filenames is easy because files/paths often have common naming convention and reside in standard locations. These can include temporary files, backup files, logs, administrative site sections, configuration files, demo applications, and sample files. These files may disclose sensitive information about the website, web application internals, database information, passwords, machine names, file paths to other sensitive areas, etc...

This will not only assist with identifying site surface which may lead to additional site vulnerabilities, but also may disclose valuable information to an attacker about the environment or its users. Predictable Resource Location is also known as Forced Browsing, Forceful Browsing, File Enumeration, and Directory Enumeration.</desc>
	<solution>Apply appropriate access control authorizations for each access to all restricted URLs, scripts or files.

Consider using MVC based frameworks such as Struts.</solution>
	<reference>http://projects.webappsec.org/Predictable-Resource-Location</reference>
	<reference>http://cwe.mitre.org/data/definitions/425.html</reference>
</vuln_item_wasc_34>

<vuln_items>wasc_35</vuln_items>
<vuln_item_wasc_35>
	<alert>SOAP Array Abuse</alert>
	<desc>XML SOAP arrays are a common target for malicious abuse. SOAP arrays are defined as having a type of "SOAP-ENC:Array" or a type derived there from. SOAP arrays have one or more dimensions (rank) whose members are distinguished by ordinal position. An array value is represented as a series of elements reflecting the array, with members appearing in ascending ordinal sequence. For multi-dimensional arrays the dimension on the right side varies most rapidly. Each member element is named as an independent element. A web-service that expects an array can be the target of a XML DoS attack by forcing the SOAP server to build a huge array in the machine's memory, thus inflicting a DoS condition on the machine due to the memory pre-allocation.</desc>
	<solution> Perform adequate input validation against any value that influences the amount of memory that is allocated. Define an appropriate strategy for handling requests that exceed the limit, and consider supporting a configuration option so that the administrator can extend the amount of memory to be used if necessary.

Run your program using system-provided resource limits for memory. This might still cause the program to crash or exit, but the impact to the rest of the system will be minimized.</solution>
	<reference>http://projects.webappsec.org/SOAP-Array-Abuse</reference>
	<reference>http://cwe.mitre.org/data/definitions/789.html</reference>
</vuln_item_wasc_35>

<vuln_items>wasc_36</vuln_items>
<vuln_item_wasc_36>
	<alert>SSI Injection</alert>
	<desc>SSI Injection (Server-side Include) is a server-side exploit technique that allows an attacker to send code into a web application, which will later be executed locally by the web server. SSI Injection exploits a web application's failure to sanitize user-supplied data before they are inserted into a server-side interpreted HTML file.

Before serving an HTML web page, a web server may parse and execute Server-side Include statements before providing it to the client. In some cases (e.g. message boards, guest books, or content management systems), a web application will insert user-supplied data into the source of a web page.

If an attacker submits a Server-side Include statement, he may have the ability to execute arbitrary operating system commands, or include a restricted file's contents the next time the page is served. This is performed at the permission level of the web server user.</desc>
	<solution>Disable SSI execution on pages that do not require it. For pages requiring SSI ensure that you perform the following checks
- Only enable the SSI directives that are needed for this page and disable all others.
- HTML entity encode user supplied data before passing it to a page with SSI execution permissions.
- Use SUExec to have the page execute as the owner of the file instead of the web server user.</solution>
	<reference>http://projects.webappsec.org/SSI-Injection</reference>
	<reference></reference>
</vuln_item_wasc_36>

<vuln_items>wasc_37</vuln_items>
<vuln_item_wasc_37>
	<alert>Session Fixation</alert>
	<desc>Session Fixation is an attack technique that forces a user's session ID to an explicit value. Depending on the functionality of the target web site, a number of techniques can be utilized to "fix" the session ID value. These techniques range from Cross-site Scripting exploits to peppering the web site with previously made HTTP requests. After a user's session ID has been fixed, the attacker will wait for that user to login. Once the user does so, the attacker uses the predefined session ID value to assume the same online identity.

Generally speaking there are two types of session management systems when it comes to ID values. The first type is "permissive" systems that allow web browsers to specify any ID. The second type is "strict" systems that only accept server-side-generated values. With permissive systems, arbitrary session IDs are maintained without contact with the web site. Strict systems require the attacker to maintain the "trap-session", with periodic web site contact, preventing inactivity timeouts.

Without active protection against Session Fixation, the attack can be mounted against any web site that uses sessions to identify authenticated users. Web sites using sessions IDs are normally cookie-based, but URLs and hidden form fields are used as well. Unfortunately, cookie-based sessions are the easiest to attack. Most of the currently identified attack methods are aimed toward the fixation of cookies.

In contrast to stealing a users' session IDs after they have logged into a web site, Session Fixation provides a much wider window of opportunity. The active part of the attack takes place before a user logs in.</desc>
	<solution>Invalidate any existing session identifiers prior to authorizing a new user session

For platforms such as ASP that do not generate new values for sessionid cookies, utilize a secondary cookie. In this approach, set a secondary cookie on the user's browser to a random value and set a session variable to the same value. If the session variable and the cookie value ever don't match, invalidate the session, and force the user to log on again.</solution>
	<reference>http://projects.webappsec.org/Session-Fixation</reference>
	<reference>http://cwe.mitre.org/data/definitions/384.html</reference>
</vuln_item_wasc_37>

<vuln_items>wasc_38</vuln_items>
<vuln_item_wasc_38>
	<alert>URL Redirector Abuse</alert>
	<desc>URL redirectors represent common functionality employed by web sites to forward an incoming request to an alternate resource. This can be done for a variety of reasons and is often done to allow resources to be moved within the directory structure and to avoid breaking functionality for users that request the resource at its previous location. URL redirectors may also be used to implement load balancing, leveraging abbreviated URLs or recording outgoing links. It is this last implementation which is often used in phishing attacks as described in the example below. URL redirectors do not necessarily represent a direct security vulnerability but can be abused by attackers trying to social engineer victims into believing that they are navigating to a site other than the true destination.</desc>
	<solution>Ipagpalagay ang lahat ng input ay malisyoso. Gamitin ang "accept known good"mahusay na pagtanngap at pagkilala o ang pag validate ng input na stratehiya,i.e., gamitin ang puting listahan o whitelist para sa pagtanggap ng ng mga input na striktong sumusunod sa pagtukoy. Tanggihan ang mga input na hindi strikto sa pag conform sa pagtutukoy o sa pag transform nito sa ibang bagay na ginagawa nito. Huwag mag rely sa eksklusibon na pagtingin sa malisyosong o di maayos na input(i.e.,huwag mag rely sa itim na listahan o sa blacklist). Gayon pa man, ang itim na listahan o ang blacklist ay maaaring magamit para sa pagdetect ng potensyal na atake o sa pagtukoy ng mga inputs ay hindi maayos na maaring tanggihan agad.

Kapag ginagamit ang input na validation, iconsider na ang lahat ng potensyal na may kaugnayan sa mga properties, kasama na rito ang haba, tipo ng input, ang buong kakayahan ng pagtanggap ng halaga, kawalan o iba pang inputs, syntax, pagkakapareho sa mga parehong larangan at pagsang-ayon sa mga panuntunan sa negosyo. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as "red" or "blue."

Use a whitelist of approved URLs or domains to be used for redirection.

Use an intermediate disclaimer page that provides the user with a clear warning that they are leaving your site. Implement a long timeout before the redirect occurs, or force the user to click on the link. Be careful to avoid XSS problems when generating the disclaimer page.

When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.

For example, ID 1 could map to "/login.asp" and ID 2 could map to "http://www.example.com/". Ang mga tampok kapareho ng ESAPI AccessReferenceMap ay naglalaan ng kakayahan na ito.

Unawain na ang lahat ng potensyal na mga lugar kung saan ang hindi pinagkakatiwalaan na pwedeng magpasok na iyong software: mga parameter at mga argumento, mga cookie, sa anumang mababasa mula sa network, mga variable sa kapaligiran, baliktad na DNS na pagtanaw, mga resulta sa query, mga header ng hiling, mga komponent ng URL, e-mail, mga file, mga database, at anumang panlabas na mga sistema na nagbibigay ng datos sa aplikasyon. Tandaan na ang mga ganong input ay maaaring hindi direktang makuha sa pamamagitan ng mga API call.

Many open redirect problems occur because the programmer assumed that certain inputs could not be modified, such as cookies and hidden form fields.</solution>
	<reference>http://projects.webappsec.org/URL-Redirector-Abuse</reference>
	<reference>http://cwe.mitre.org/data/definitions/601.html</reference>
</vuln_item_wasc_38>

<vuln_items>wasc_39</vuln_items>
<vuln_item_wasc_39>
	<alert>XPath Injection</alert>
	<desc>XPath Injection is an attack technique used to exploit applications that construct XPath (XML Path Language) queries from user-supplied input to query or navigate XML documents. It can be used directly by an application to query an XML document, as part of a larger operation such as applying an XSLT transformation to an XML document, or applying an XQuery to an XML document. The syntax of XPath bears some resemblance to an SQL query, and indeed, it is possible to form SQL-like queries on an XML document using XPath.

If an application uses run-time XPath query construction, embedding unsafe user input into the query, it may be possible for the attacker to inject data into the query such that the newly formed query will be parsed in a way differing from the programmer's intention.</desc>
	<solution>Use parameterized XPath queries (e.g. using XQuery). This will help ensure separation between data plane and control plane.

Properly validate user input. Reject data where appropriate, filter where appropriate and escape where appropriate. Make sure input that will be used in XPath queries is safe in that context.</solution>
	<reference>http://projects.webappsec.org/XPath-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/643.html</reference>
</vuln_item_wasc_39>

<vuln_items>wasc_40</vuln_items>
<vuln_item_wasc_40>
	<alert>Insufficient Process Validation</alert>
	<desc>Insufficient Process Validation occurs when a web application fails to prevent an attacker from circumventing the intended flow or business logic of the application. When seen in the real world, insufficient process validation has resulted in ineffective access controls and monetary loss.

There are two main types of processes that require validation: flow control and business logic.

"Flow control" refers to multi-step processes that require each step to be performed in a specific order by the user. When an attacker performs the step incorrectly or out of order, the access controls may be bypassed and an application integrity error may occur. Examples of multi-step processes include wire transfer, password recovery, purchase checkout, and account sign-up.

"Business logic" refers to the context in which a process will execute as governed by the business requirements. Exploiting a business logic weakness requires knowledge of the business; if no knowledge is needed to exploit it, then most likely it isn't a business logic flaw. Due to this, typical security measures such as scans and code review will not find this class of weakness. One approach to testing is offered by OWASP in their Testing Guide.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Insufficient-Process-Validation</reference>
	<reference></reference>
</vuln_item_wasc_40>

<vuln_items>wasc_41</vuln_items>
<vuln_item_wasc_41>
	<alert>XML Attribute Blowup</alert>
	<desc>XML Attribute Blowup is a denial of service attack against XML parsers. The attacker provides a malicious XML document, which vulnerable XML parsers process in a very inefficient manner, leading to excessive CPU load. The essence of the attack is to include many attributes in the same XML node. Vulnerable XML parsers manage the attributes in an inefficient manner (e.g. in a data container for which insertion of a new attribute has O(n) runtime), resulting in a non-linear (in this example, quadratic, i.e. O(n2)) overall runtime, leading to a denial of service condition via CPU exhaustion.</desc>
	<solution>Design throttling mechanisms into the system architecture. Ang pinakamainam na proteksyon ay limitahan ang halaga ng yaman na ang di-awtorisadong user ay maaring makadulot upang gastahin. Ang isang matibay na pagpapatunay at modelo ng access kontrol ay makakatulog na maiwasan ang gayong mga pag-atake mula sa nangyaring unang naganap. Ang login na aplikasyon ay dapat protektado laban sa pag-atake ng DoS hangga't maaari. Nilimitahan ang access sa database, marahil sa caching na nakalagay na resulta, makakatulong sa pagbawas ang pinagkukunan na ginasta. Para sa karagdagang limit ng potensyal para sa isang atake ng DoS, isaalang-alang ang taas ng halaga ng mga natatanggap na kahilingan mula sa mga gumagamit at bumabara ang mga hiling na lumagpas sa isang tinukoy na halaga ng limitasyon.

Mitigation of resource exhaustion attacks requires that the target system either:
 * recognizes the attack and denies that user further access for a given amount of time, or
 * uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed. 

Ang una sa mga solusyon ay isang isyu sa sarili bagaman, dahil maari itong payagan ang mga nag-aatake na maiwasan ang paggamit ng sistema sa pamamagitan ng isang balidong gumagamit. Kung ang umatake ay kinokopya ang balidong gumagamit, pwede nitong pigilan ang gumagamit mula sa pagpasok sa server sa pagtatanong.

Ang pangalawang solusyon ay mahirap lamang sa epektibong istitute -- at kahit na isaktong matapos, ito ay hindi nagbibigay ng isang buong solusyon. Ito lang ay gumagawa sa atake na nangangailangan ng higit pang mapagkukunan ng parte sa umaatake.

Tiyakin na ang mga protocol ay partikular ang mga limit ng scale na inilagay sa kanila.

Ensure that all failures in resource allocation place the system into a safe posture.</solution>
	<reference>http://projects.webappsec.org/XML-Attribute-Blowup</reference>
	<reference>http://cwe.mitre.org/data/definitions/400.html</reference>
</vuln_item_wasc_41>

<vuln_items>wasc_42</vuln_items>
<vuln_item_wasc_42>
	<alert>Abuse of Functionality</alert>
	<desc>Abuse of Functionality is an attack technique that uses a web site's own features and functionality to attack itself or others. Abuse of Functionality can be described as the abuse of an application's intended functionality to perform an undesirable outcome. These attacks have varied results such as consuming resources, circumventing access controls, or leaking information. The potential and level of abuse will vary from web site to web site and application to application. Abuse of functionality attacks are often a combination of other attack types and/or utilize other attack vectors.</desc>
	<solution>Always utilize APIs in the specified manner.</solution>
	<reference>http://projects.webappsec.org/Abuse-of-Functionality</reference>
	<reference>http://cwe.mitre.org/data/definitions/227.html</reference>
</vuln_item_wasc_42>

<vuln_items>wasc_43</vuln_items>
<vuln_item_wasc_43>
	<alert>XML External Entities</alert>
	<desc>This technique takes advantage of a feature of XML to build documents dynamically at the time of processing. An XML message can either provide data explicitly or by pointing to an URI where the data exists. In the attack technique, external entities may replace the entity value with malicious data, alternate referrals or may compromise the security of the data the server/XML application has access to.
	Attackers may also use External Entities to have the web services server download malicious code or content to the server for use in secondary or follow on attacks.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/XML-External-Entities</reference>
	<reference></reference>
</vuln_item_wasc_43>

<vuln_items>wasc_44</vuln_items>
<vuln_item_wasc_44>
	<alert>XML Entity Expansion</alert>
	<desc>The XML Entity expansion attack, exploits a capability in XML DTDs that allows the creation of custom macros, called entities, that can be used throughout a document. By recursively defining a set of custom entities at the top of a document, an attacker can overwhelm parsers that attempt to completely resolve the entities by forcing them to iterate almost indefinitely on these recursive definitions.

The malicious XML message is used to force recursive entity expansion (or other repeated processing) that completely uses up available server resources.</desc>
	<solution>If possible, prohibit the use of DTDs or use an XML parser that limits the expansion of recursive DTD entities.

Before parsing XML files with associated DTDs, scan for recursive entity declarations and do not continue parsing potentially explosive content.</solution>
	<reference>http://projects.webappsec.org/XML-Entity-Expansion</reference>
	<reference>http://cwe.mitre.org/data/definitions/776.html</reference>
</vuln_item_wasc_44>

<vuln_items>wasc_45</vuln_items>
<vuln_item_wasc_45>
	<alert>Fingerprinting</alert>
	<desc>The most common methodology for attackers is to first footprint the target's web presence and enumerate as much information as possible. With this information, the attacker may develop an accurate attack scenario, which will effectively exploit a vulnerability in the software type/version being utilized by the target host.

Multi-tier fingerprinting is similar to its predecessor, TCP/IP Fingerprinting (with a scanner such as Nmap) except that it is focused on the Application Layer of the OSI model instead of the Transport Layer. The theory behind this fingerprinting is to create an accurate profile of the target's platform, web application software technology, backend database version, configurations and possibly even their network architecture/topology.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Fingerprinting</reference>
	<reference></reference>
</vuln_item_wasc_45>

<vuln_items>wasc_46</vuln_items>
<vuln_item_wasc_46>
	<alert>XQuery Injection</alert>
	<desc>XQuery Injection is a variant of the classic SQL injection attack against the XML XQuery Language. XQuery Injection uses improperly validated data that is passed to XQuery commands. This inturn will execute commands on behalf of the attacker that the XQuery routines have access to. XQuery injection can be used to enumerate elements on the victim's environment, inject commands to the local host, or execute queries to remote files and data sources. Like SQL injection attacks, the attacker tunnels through the application entry point to target the resource access layer.</desc>
	<solution>Use parameterized queries. This will help ensure separation between data plane and control plane.

Properly validate user input. Reject data where appropriate, filter where appropriate and escape where appropriate. Make sure input that will be used in XQL queries is safe in that context.</solution>
	<reference>http://projects.webappsec.org/XQuery-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/652.html</reference>
</vuln_item_wasc_46>

<vuln_items>wasc_47</vuln_items>
<vuln_item_wasc_47>
	<alert>Insufficient Session Expiration</alert>
	<desc>Insufficient Session Expiration occurs when a Web application permits an attacker to reuse old session credentials or session IDs for authorization. Insufficient Session Expiration increases a Web site's exposure to attacks that steal or reuse user's session identifiers.

Since HTTP is a stateless protocol, Web sites commonly use cookies to store session IDs that uniquely identify a user from request to request. Consequently, each session ID's confidentiality must be maintained in order to prevent multiple users from accessing the same account. A stolen session ID can be used to view another user's account or perform a fraudulent transaction.

Session expiration is comprised of two timeout types: inactivity and absolute. An absolute timeout is defined by the total amount of time a session can be valid without re-authentication and an inactivity timeout is the amount of idle time allowed before the session is invalidated. The lack of proper session expiration may increase the likelihood of success of certain attacks. A long expiration time increases an attacker's chance of successfully guessing a valid session ID. The longer the expiration time, the more concurrent open sessions will exist at any given time. The larger the pool of sessions, the more likely it will be for an attacker to guess one at random. Although a short session inactivity timeout does not help if a token is immediately used, the short timeout helps to insure that the token is harder to capture while it is still valid.

A Web application should invalidate a session after a predefined idle time has passed (a timeout) and provide the user the means to invalidate their own session, i.e. logout; this helps to keep the lifespan of a session ID as short as possible and is necessary in a shared computing environment where more than one person has unrestricted physical access to a computer. The logout function should be prominently visible to the user, explicitly invalidate a user‚Äôs session and disallow reuse of the session token.</desc>
	<solution>Set sessions/credentials expiration date.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Session-Expiration</reference>
	<reference>http://cwe.mitre.org/data/definitions/613.html</reference>
</vuln_item_wasc_47>

<vuln_items>wasc_48</vuln_items>
<vuln_item_wasc_48>
	<alert>Insecure Indexing</alert>
	<desc>Insecure Indexing is a threat to the data confidentiality of the web-site. Indexing web-site contents via a process that has access to files which are not supposed to be publicly accessible has the potential of leaking information about the existence of such files, and about their content. In the process of indexing, such information is collected and stored by the indexing process, which can later be retrieved (albeit not trivially) by a determined attacker, typically through a series of queries to the search engine. The attacker does not thwart the security model of the search engine. As such, this attack is subtle and very hard to detect and to foil - it‚Äôs not easy to distinguish the attacker‚Äôs queries from a legitimate user‚Äôs queries.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Insecure-Indexing</reference>
	<reference></reference>
</vuln_item_wasc_48>

<vuln_items>wasc_49</vuln_items>
<vuln_item_wasc_49>
	<alert>Insufficient Password Recovery</alert>
	<desc>Insufficient Password Recovery is when a web site permits an attacker to illegally obtain, change or recover another user's password. Conventional web site authentication methods require users to select and remember a password or passphrase. The user should be the only person that knows the password and it must be remembered precisely. As time passes, a user's ability to remember a password fades. The matter is further complicated when the average user visits 20 sites requiring them to supply a password.  (RSA Survey: http://news.bbc.co.uk/1/hi/technology/3639679.stm) Thus, password recovery is an important part in servicing online users.

Examples of automated password recovery processes include requiring the user to answer a "secret question" defined as part of the user registration process. This question can either be selected from a list of canned questions or supplied by the user. Another mechanism in use is having the user provide a "hint" during registration that will help the user remember his password. Other mechanisms require the user to provide several pieces of personal data such as their social security number, home address, zip code etc. to validate their identity. After the user has proven who they are, the recovery system will display or e-mail them a new password.

A web site is considered to have Insufficient Password Recovery when an attacker is able to foil the recovery mechanism being used. This happens when the information required to validate a user's identity for recovery is either easily guessed or can be circumvented. Password recovery systems may be compromised through the use of brute force attacks, inherent system weaknesses, or easily guessed secret questions.</desc>
	<solution>Make sure that all input supplied by the user to the password recovery mechanism is thoroughly filtered and validated

Do not use standard weak security questions and use several security questions.

Make sure that there is throttling on the number of incorrect answers to a security question. Disable the password recovery functionality after a certain (small) number of incorrect guesses.

Require that the user properly answers the security question prior to resetting their password and sending the new password to the e-mail address of record.

Never allow the user to control what e-mail address the new password will be sent to in the password recovery mechanism.

Assign a new temporary password rather than revealing the original password.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Password-Recovery</reference>
	<reference>http://cwe.mitre.org/data/definitions/640.html</reference>
</vuln_item_wasc_49>

</vulnerabilities>